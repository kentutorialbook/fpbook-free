<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="timeline FRP Monad">
<meta name="keywords" content="monoid, functor, monad, functional programming, funcction, JavaScript, ECMAScript, Promise, FRP, io-next, 関数型プログラミング, モナド, プログラミング, mathmatics">
<meta name="author" content="岡部　健 / Ken Okabe &lt;kentutorialbook@gmail.com&gt;">
<title>忙しいプログラマーのための関数型プログラミング　Functional Programming for the Working Programmer</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
@import "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css";
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Source Code Pro", "Source Han Serif JP","Source Han Sans JP","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote::before{display:none}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{word-spacing:0;line-height:1.6}
.quoteblock.abstract blockquote::before,.quoteblock.abstract p::before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}

th,td {
    border: solid 0px;  
}　

p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left data-line-1">
<div id="header">
<h1>忙しいプログラマーのための関数型プログラミング　Functional Programming for the Working Programmer</h1>
<div class="details">
<span id="author" class="author">岡部　健 / Ken Okabe &lt;kentutorialbook@gmail.com&gt;</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#_unit_1_パラダイム_paradaigm">🟧 UNIT 1 : パラダイム Paradaigm</a>
<ul class="sectlevel1">
<li><a href="#_いったい何が問題なのか">1. いったい何が問題なのか？？</a></li>
<li><a href="#_ほぼすべてのプログラミング入門者が半ば強制的に辿る道命令型プログラミング">2. ほぼすべてのプログラミング入門者が半ば強制的に辿る道＝命令型プログラミング</a>
<ul class="sectlevel2">
<li><a href="#_start_from_scratchゼロからのスタート">2.1. Start from Scratch（ゼロからのスタート）</a></li>
<li><a href="#_まとめ">2.2. まとめ</a></li>
</ul>
</li>
<li><a href="#_文statementから式expressionへ関数型プログラミング">3. 文(statement)から式(expression)へ＝関数型プログラミング</a>
<ul class="sectlevel2">
<li><a href="#_関数型プログラミングのコードは数式">3.1. 関数型プログラミングのコードは「数式」</a></li>
<li><a href="#_命令型プログラミングのコードは文statementの集まり">3.2. 命令型プログラミングのコードは「文(statement)」の集まり</a></li>
<li><a href="#_1_2_3二項演算を軸とした関数型プログラミングのコード">3.3. 1 + 2 = 3　二項演算を軸とした関数型プログラミングのコード</a></li>
<li><a href="#_二項演算は2つの引数をとる関数">3.4. 二項演算は2つの引数をとる関数</a></li>
<li><a href="#_関数をfxとする記法はbestではない">3.5. 関数をf(x)とする記法はBestではない</a></li>
<li><a href="#_ユーザ定義が可能な演算子">3.6. ユーザ定義が可能な演算子</a></li>
<li><a href="#_オブジェクト指向と二項演算の意外な関係性">3.7. オブジェクト指向と二項演算の意外な関係性</a></li>
<li><a href="#_関数function値value">3.8. 関数(function)=値(value)</a></li>
<li><a href="#_式expresssion値value">3.9. 式(expresssion)=値(value)</a></li>
<li><a href="#_二項演算を軸とした関数型プログラミングのコードの全体像">3.10. 二項演算を軸とした関数型プログラミングのコードの全体像</a></li>
<li><a href="#_式expression値value関数functionが再び式の要素になる関数型コード">3.11. 式(expression)＝値(value)/関数(function)が再び式の要素になる=関数型コード</a></li>
</ul>
</li>
<li><a href="#_複雑さとの闘いのための最終兵器結合性">4. 複雑さとの闘いのための最終兵器＝結合性</a>
<ul class="sectlevel2">
<li><a href="#_コーディングは複雑さとの闘い">4.1. コーディングは複雑さとの闘い</a></li>
<li><a href="#_monoidモノイド">4.2. Monoid(モノイド)</a></li>
<li><a href="#_レゴブロックは_monoidモノイド">4.3. レゴブロックは Monoid(モノイド)</a></li>
<li><a href="#_usb機器はmonoidモノイド">4.4. USB機器はMonoid(モノイド)</a></li>
<li><a href="#_文字列はmonoidモノイド">4.5. 文字列はMonoid(モノイド)</a></li>
</ul>
</li>
<li><a href="#_値と演算と関数と定義域のはなし型は集合_types_as_sets">5. 「値と演算」と「関数と定義域」のはなし　型は集合 Types as Sets</a>
<ul class="sectlevel2">
<li><a href="#_値と演算はペア">5.1. 値と演算はペア</a></li>
<li><a href="#_型とは集合のこと_types_as_sets">5.2. 型とは集合のこと Types as Sets</a></li>
<li><a href="#_type_theory_versus_set_theory">5.3. Type theory versus set theory</a></li>
<li><a href="#_types_as_sets">5.4. Types as Sets</a></li>
<li><a href="#_巷によくあるよくわからない型の説明">5.5. 巷によくある、よくわからない「型」の説明</a></li>
</ul>
</li>
<li><a href="#_関数のための演算子">6. 関数のための演算子</a>
<ul class="sectlevel2">
<li><a href="#_パイプライン演算子pipeline_operator">6.1. パイプライン演算子(Pipeline operator)</a></li>
<li><a href="#_合成関数写像の合成">6.2. 合成関数（写像の合成）</a></li>
<li><a href="#_写像関数の合成はmonoidモノイド">6.3. 写像/関数の合成はMonoid(モノイド)</a></li>
<li><a href="#_関数合成演算子">6.4. 関数合成演算子</a></li>
</ul>
</li>
<li><a href="#_functorendofunctor">7. Functor(endoFunctor)</a>
<ul class="sectlevel2">
<li><a href="#_関数合成">7.1. 関数合成</a></li>
<li><a href="#_array_map">7.2. Array.map()</a></li>
<li><a href="#_identity_と_functorという二項演算">7.3. identity と Functorという二項演算</a></li>
<li><a href="#_もっともシンプルなfunctoridentityfunctor_それはパイプラインという二項演算">7.4. もっともシンプルなFunctor=identityFunctor それはパイプラインという二項演算</a></li>
<li><a href="#_関数の合成もendofunctor">7.5. 関数の合成も(endo)Functor</a></li>
<li><a href="#_関数の合成はmonadモナド">7.6. 関数の合成はMonad(モナド)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_unit_2_フローから依存グラフの式へ">🟧 UNIT 2 : フローから依存グラフの式へ</a>
<ul class="sectlevel1">
<li><a href="#_条件分岐">1. 条件分岐</a></li>
<li><a href="#_依存グラフ">2. 依存グラフ</a>
<ul class="sectlevel2">
<li><a href="#_フローがなくイミュータブルな式のコード関数型プログラミング">2.1. フローがなくイミュータブルな式のコード＝関数型プログラミング</a></li>
</ul>
</li>
<li><a href="#_世界モデル">3. 世界モデル</a>
<ul class="sectlevel2">
<li><a href="#_関数型プログラミングの実用化に立ち塞がる最大のメンタルブロック">3.1. 関数型プログラミングの実用化に立ち塞がる最大のメンタルブロック</a></li>
<li><a href="#_世界モデル数学と物理学と時間">3.2. 世界モデル　数学と物理学と時間</a></li>
</ul>
</li>
<li><a href="#_frpスプレッドシート">4. FRP　スプレッドシート</a>
<ul class="sectlevel2">
<li><a href="#_永続データ構造_たとえばgitとか">4.1. 永続データ構造 たとえばGitとか</a></li>
<li><a href="#_巷で非同期処理と呼ばれるものの正体">4.2. 巷で「非同期処理」と呼ばれるものの正体</a></li>
<li><a href="#_promise">4.3. Promise</a></li>
<li><a href="#_時間軸マッピング">4.4. 時間軸マッピング</a></li>
<li><a href="#_スプレッドシートのようにコーディングする">4.5. スプレッドシートのようにコーディングする</a></li>
<li><a href="#_依存関係を解決する">4.6. 依存関係を解決する</a></li>
<li><a href="#_reactive_functor">4.7. Reactive Functor</a></li>
<li><a href="#_reactive_monad">4.8. Reactive Monad</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_unit_3_数学_mathematics">🟧 UNIT 3 : 数学 Mathematics</a>
<ul class="sectlevel1">
<li><a href="#_代数的構造">1. 代数的構造</a></li>
<li><a href="#_結合性associativityとモノイドmonoid">2. 結合性(associativity)とモノイド(monoid)</a></li>
<li><a href="#function">3. 関数を知ろう</a>
<ul class="sectlevel2">
<li><a href="#know_function">3.1. 関数</a></li>
<li><a href="#_関数の具体例">3.2. 関数の具体例</a></li>
<li><a href="#_関数のテーブル">3.3. 関数のテーブル</a></li>
<li><a href="#_数学法則を使う関数">3.4. 数学法則を使う関数</a></li>
<li><a href="#_関数の表記">3.5. 関数の表記</a></li>
</ul>
</li>
<li><a href="#_集合と写像">4. 集合と写像</a>
<ul class="sectlevel2">
<li><a href="#_集合と写像_2">4.1. 集合と写像</a></li>
<li><a href="#_関数と定義域domainと終域値域rangeと型type">4.2. 関数と定義域(domain)と終域値域(range)と型(type)</a></li>
</ul>
</li>
<li><a href="#_関数の表記_2">5. 関数の表記</a>
<ul class="sectlevel2">
<li><a href="#_関数を定義するタイミングとそれ以外の操作のタイミングの２種類の表記がある">5.1. 関数を定義するタイミングと、それ以外の操作のタイミングの２種類の表記がある</a></li>
<li><a href="#_javascriptの関数">5.2. JavaScriptの関数</a></li>
</ul>
</li>
<li><a href="#_高階関数">6. 高階関数</a>
<ul class="sectlevel2">
<li><a href="#_配列とオブジェクト連想配列は関数として機能する">6.1. 配列とオブジェクト(連想配列)は関数として機能する</a></li>
<li><a href="#_配列とオブジェクトの多重構造">6.2. 配列とオブジェクトの多重構造</a></li>
<li><a href="#_関数は複数のインプットを処理できる">6.3. 関数は複数のインプットを処理できる</a></li>
<li><a href="#_複数のインプットをとる関数へのおきかえ">6.4. 複数のインプットをとる関数へのおきかえ</a></li>
<li><a href="#_アウトプットが関数である高階関数">6.5. アウトプットが関数、である高階関数</a></li>
<li><a href="#_関数のカリー化と部分適用">6.6. 関数のカリー化と部分適用</a></li>
<li><a href="#_インプットが関数である高階関数">6.7. インプットが関数、である高階関数</a></li>
<li><a href="#_インプットが関数アウトプットが関数である高階関数">6.8. インプットが関数、アウトプットが関数、である高階関数</a></li>
<li><a href="#_関数の構成はかんたんで自由自在">6.9. 関数の構成はかんたんで自由自在</a></li>
</ul>
</li>
<li><a href="#_演算子">7. 演算子</a>
<ul class="sectlevel2">
<li><a href="#_単項演算子">7.1. 単項演算子</a></li>
<li><a href="#_二項演算子">7.2. 二項演算子</a></li>
<li><a href="#_三項演算子条件演算子">7.3. 三項演算子(条件演算子)</a></li>
</ul>
</li>
<li><a href="#_functor">8. Functor</a></li>
<li><a href="#_monadモナドfrp">9. Monad(モナド)　FRP</a></li>
<li><a href="#_reactivemonad_io_next">10. ReactiveMonad io-next</a></li>
</ul>
</li>
<li><a href="#_license">License</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}

p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};

</style>
<div class="exampleblock data-line-28">
<div class="content">
<div class="paragraph data-line-30">
<p>2021/1/中旬リリースを予定しているプログラミング電子書籍のアルファ版を無料公開しています。<br>
この公開ドキュメント自体随時アップデートされますが、最終的な公開範囲については未定です。<br>
製品版は、学生向gけには無料、社会人、プロのプログラマー向けには有料を予定しています。<br>
価格は、複数ボリュームで、合計9000円ほど。デジタルコンテンツとして永続的にアップデートされ通知されます。</p>
</div>
<div class="paragraph data-line-35">
<p><strong>リリース日までは別途専用のGoogleグループにメール登録することで、最新情報の通知が届きます。</strong></p>
</div>
<div class="paragraph data-line-37">
<p>配信専用
<a href="https://groups.google.com/g/functional-programming-for-the-working-programmer" class="bare">https://groups.google.com/g/functional-programming-for-the-working-programmer</a></p>
</div>
<div class="paragraph data-line-41">
<p><strong>現在、本書籍のアルファ、ベータバージョンのレビュワーを募集しております。</strong></p>
</div>
<div class="paragraph data-line-43">
<p>★ リターン</p>
</div>
<div class="ulist data-line-45">
<ul>
<li class="data-line-45">
<p>電子書籍全セット(9000円相当)無料、永続アップデート込</p>
</li>
<li class="data-line-46">
<p>期間中、プログラミングに関する質問、相談無料 どのレベルでもOK</p>
</li>
<li class="data-line-47">
<p>関連して書籍に盛り込んでほしい内容、具体的なコードサンプルのリクエスト可</p>
</li>
</ul>
</div>
<div class="paragraph data-line-49">
<p>★ ご協力いただきたい要件</p>
</div>
<div class="ulist data-line-51">
<ul>
<li class="data-line-51">
<p>活動が確認できるSNSアカウントやブログ(捨てアカウントなどはご遠慮ください)</p>
</li>
<li class="data-line-52">
<p>SNSやブログを通じて、フォロワーへの当書籍のリリースの告知など、販売プロモーションへの参加</p>
</li>
<li class="data-line-53">
<p>SNSやブログを通して、書籍のレビュー Qiita投稿なども自由</p>
</li>
<li class="data-line-54">
<p>Googleグループやメールを通じて、著者へのフィードバック</p>
</li>
<li class="data-line-55">
<p>関連して書籍に盛り込む内容、具体的なコードサンプルのリクエスト可、たとえば現在こういうコードを書いているのだけど、関数型のコードではどうなるのか？など</p>
</li>
</ul>
</div>
<div class="paragraph data-line-57">
<p><a href="mailto:kentutorialbook@gmail.com">kentutorialbook@gmail.com</a><br>
まで、ご活動が確認できるSNSアカウントやブログなどのURLを添えて、是非お知らせください。</p>
</div>
</div>
</div>
<div class="paragraph lead data-line-63">
<p><strong>🟧 UNIT 1</strong>
プログラミングのおおまかな枠組み、パラダイムについて解説していきます。</p>
</div>
<div class="paragraph lead data-line-67">
<p><strong>🟧 UNIT 2</strong>
より具体的に、命令型コードのフローを関数型コードの式で表現する依存グラフへ置き換える方法について解説していきます。命令型思考による概念＝いわゆる「非同期処理」もこの枠組みへ統合します。( <em>UNIT2の現在の完成度は50％以下です</em> )</p>
</div>
<div class="paragraph lead data-line-71">
<p><strong>🟧 UNIT 3</strong>
より詳細な数学的要素、そもそも関数(function)とは？型(type)って何？モノイド(monoid)、モナド(monad)などについて解説していきます。( <em>UNIT3の現在の完成度は30％以下です</em> )</p>
</div>
</div>
</div>
<h1 id="_unit_1_パラダイム_paradaigm" class="sect0 data-line-76">🟧 UNIT 1 : パラダイム Paradaigm</h1>
<div class="sect1 data-line-4">
<h2 id="_いったい何が問題なのか">1. いったい何が問題なのか？？</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="imageblock data-line-80">
<div class="content">
<img src="./img/5-12-2020-17-00-09-PM.png" alt="5 12 2020 17 00 09 PM">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4">
<h2 id="_ほぼすべてのプログラミング入門者が半ば強制的に辿る道命令型プログラミング">2. ほぼすべてのプログラミング入門者が半ば強制的に辿る道＝命令型プログラミング</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="sect2 data-line-15">
<h3 id="_start_from_scratchゼロからのスタート">2.1. Start from Scratch（ゼロからのスタート）</h3>
<div class="paragraph data-line-17">
<p><a href="https://ja.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">命令型プログラミング</a>（<a href="https://en.wikipedia.org/wiki/Imperative_programming">Imperative Programming</a>）は、コンピュータと呼ばれる物理的なハードウェアに順番に命令を送るという一連のシークエンスを並べる作業のことで、命令を送ればそのとおり動作するのだろう、という極めて自然で直感的にも理解しやすい原始的なやり方です。</p>
</div>
<div class="paragraph data-line-19">
<p>2020年現在、ほぼすべてのプログラミング入門者は、まず命令型プログラミングの作法（<a href="https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0">プログラミングパラダイム</a> (<a href="https://en.wikipedia.org/wiki/Programming_paradigm">programming paradigm</a>)）を徹底的に叩き込まれることになっています。</p>
</div>
<div class="paragraph data-line-22">
<p>これは、古典的で素朴なプログラミングの作法を学ぶという意味では正しいかもしれません。そして将来的にこの状況が改革されるのかどうかも良くわかりません。</p>
</div>
<div class="imageblock data-line-24">
<div class="content">
<img src="./img/2-12-2020-14-26-30-PM.png" alt="2 12 2020 14 26 30 PM">
</div>
</div>
<div class="paragraph data-line-26">
<p><a href="https://www.nhk.or.jp/school/programming/start/index.html" class="bare">https://www.nhk.or.jp/school/programming/start/index.html</a></p>
</div>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=kenec201702-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4865103929&linkId=a8910a2dbc778f885c734653a43b3f4f"></iframe>
<div class="paragraph data-line-32">
<p>命令型プログラミングのコードとは以下のようなものです。</p>
</div>
<div class="paragraph data-line-34">
<p>1から10までの数を足すコード</p>
</div>
<div class="imageblock data-line-36">
<div class="content">
<img src="./img/4-7-2020-05-45-46-AM.png" alt="4 7 2020 05 45 46 AM">
</div>
</div>
<div class="imageblock data-line-38">
<div class="content">
<img src="./img/4-7-2020-05-48-23-AM.png" alt="4 7 2020 05 48 23 AM">
</div>
</div>
<div class="paragraph data-line-40">
<p>ここで、たとえば</p>
</div>
<div class="paragraph data-line-42">
<p><code>x = x + 1</code></p>
</div>
<div class="paragraph data-line-44">
<p>というコードがありますが、これは実際には3つの操作を表現しています。</p>
</div>
<div class="paragraph data-line-46">
<p>1.<code>X</code> に割り当てられているメモリに格納された値を読み取る<br>
2.その値をひとつ増やす<br>
3.新しい値を <code>X</code> に割り当てられているメモリに書き込む</p>
</div>
<hr>
<div class="paragraph data-line-52">
<p><a href="https://dl.acm.org/doi/10.1145/359576.359579">Can Programming Be Liberated from the von
Neumann Style? A Functional Style and Its
Algebra of Programs</a></p>
</div>
<div class="paragraph data-line-56">
<p><strong>プログラミングはフォン・ノイマン・スタイルから解放されうるか?関数型プログラミング・スタイルとそのプログラム代数</strong></p>
</div>
<div class="paragraph data-line-58">
<p>という講演が、FORTRANの作者であるジョン・バッカスによってなされました。</p>
</div>
<div class="paragraph data-line-60">
<p>どういうことでしょうか？</p>
</div>
<div class="paragraph data-line-63">
<p>現代数学の基礎となる圏論を関数型プログラミングに紐づけて解説することで著名な数学者であるBartosz Milewski (@BartoszMilewski)氏は一連のYouTube動画の最初に以下のようにスピーチしています。</p>
</div>
<div class="paragraph data-line-65">
<p><a href="https://youtu.be/I8LbkfSSR58?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_" class="bare">https://youtu.be/I8LbkfSSR58?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_</a></p>
</div>
<div class="imageblock data-line-67">
<div class="content">
<img src="./img/2-12-2020-15-19-38-PM.png" alt="2 12 2020 15 19 38 PM">
</div>
</div>
<div class="paragraph data-line-68">
<p>Ok、自分がプログラミングをはじめたとき、アセンブリ言語からはじめた。</p>
</div>
<div class="imageblock data-line-70">
<div class="content">
<img src="./img/2-12-2020-15-21-51-PM.png" alt="2 12 2020 15 21 51 PM">
</div>
</div>
<div class="paragraph data-line-71">
<p>考えうる限りもっとも低いレベルだね。何をすべきなのかを実際にコンピュータに正確に指示していく。</p>
</div>
<div class="imageblock data-line-73">
<div class="content">
<img src="./img/2-12-2020-15-22-58-PM.png" alt="2 12 2020 15 22 58 PM">
</div>
</div>
<div class="paragraph data-line-74">
<p>メモリからこれを掴み取って、それをレジスタに配置する、とか書いていく</p>
</div>
<div class="imageblock data-line-76">
<div class="content">
<img src="./img/2-12-2020-15-23-56-PM.png" alt="2 12 2020 15 23 56 PM">
</div>
</div>
<div class="paragraph data-line-77">
<p>それをアドレスとして利用して、そこにジャンプする、などなど、極めて正確にコンピュータに何をすべきか指示していく</p>
</div>
<div class="imageblock data-line-79">
<div class="content">
<img src="./img/2-12-2020-15-24-39-PM.png" alt="2 12 2020 15 24 39 PM">
</div>
</div>
<div class="paragraph data-line-80">
<p>これが、まさに我々が始めた命令型プログラミングのやり方というものだ。</p>
</div>
<div class="imageblock data-line-82">
<div class="content">
<img src="./img/2-12-2020-15-26-06-PM.png" alt="2 12 2020 15 26 06 PM">
</div>
</div>
<div class="paragraph data-line-83">
<p>そしてこれはどこかのポイントで、反学習する（忘れる）必要がある。</p>
</div>
<div class="imageblock data-line-85">
<div class="content">
<img src="./img/2-12-2020-15-26-57-PM.png" alt="2 12 2020 15 26 57 PM">
</div>
</div>
<div class="paragraph data-line-86">
<p>このプログラミングのアプローチは、コンピュータ・サイエンスでは、チューリングマシンと関連がある。</p>
</div>
<div class="imageblock data-line-88">
<div class="content">
<img src="./img/2-12-2020-15-27-43-PM.png" alt="2 12 2020 15 27 43 PM">
</div>
</div>
<div class="paragraph data-line-89">
<p>チューリングマシンは原始的なマシンで、紙テープがあってなんかスタンプしていくだけだ</p>
</div>
<div class="imageblock data-line-91">
<div class="content">
<img src="./img/2-12-2020-15-28-30-PM.png" alt="2 12 2020 15 28 30 PM">
</div>
</div>
<div class="paragraph data-line-92">
<p>ここにはハイレベルなプログラミンはない。それはちょうど</p>
</div>
<div class="imageblock data-line-94">
<div class="content">
<img src="./img/2-12-2020-15-29-42-PM.png" alt="2 12 2020 15 29 42 PM">
</div>
</div>
<div class="paragraph data-line-95">
<p>「番号を読み込め、テープにそれを書き戻せ、テープから何かを消せ」などなど、アセンブリ言語のようなものだ。</p>
</div>
<div class="imageblock data-line-97">
<div class="content">
<img src="./img/2-12-2020-15-30-38-PM.png" alt="2 12 2020 15 30 38 PM">
</div>
</div>
<div class="paragraph data-line-98">
<p>これは、ひとつのプログラミングへのアプローチではある。</p>
</div>
<div class="imageblock data-line-100">
<div class="content">
<img src="./img/2-12-2020-15-31-43-PM.png" alt="2 12 2020 15 31 43 PM">
</div>
</div>
<div class="paragraph data-line-101">
<p>ところで、こういうプログラミングへのアプローチは、コンピュータが存在する前から発明されていた。</p>
</div>
<div class="imageblock data-line-103">
<div class="content">
<img src="./img/2-12-2020-15-32-27-PM.png" alt="2 12 2020 15 32 27 PM">
</div>
</div>
<div class="paragraph data-line-104">
<p>それから、別のプログラミングへのアプローチがある。</p>
</div>
<div class="imageblock data-line-106">
<div class="content">
<img src="./img/2-12-2020-15-34-48-PM.png" alt="2 12 2020 15 34 48 PM">
</div>
</div>
<div class="paragraph data-line-107">
<p>これは数学からやってきたもので、アロンゾ・チャーチらによるラムダ計算だ。</p>
</div>
<div class="imageblock data-line-109">
<div class="content">
<img src="./img/2-12-2020-15-35-29-PM.png" alt="2 12 2020 15 35 29 PM">
</div>
</div>
<div class="paragraph data-line-110">
<p>これは「何が計算可能なのか」というようなものだ。</p>
</div>
<div class="imageblock data-line-112">
<div class="content">
<img src="./img/2-12-2020-15-36-42-PM.png" alt="2 12 2020 15 36 42 PM">
</div>
</div>
<div class="imageblock data-line-114">
<div class="content">
<img src="./img/2-12-2020-15-37-32-PM.png" alt="2 12 2020 15 37 32 PM">
</div>
</div>
<div class="paragraph data-line-115">
<p>ものごとが実際にどのように実行できるのか、ある意味、ものごとを変換していく、という観点で数学的に考えていく。</p>
</div>
<hr>
<div class="paragraph data-line-120">
<p><a href="https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97">ラムダ計算</a>は、関数型プログラミングの理論的基礎となっています。</p>
</div>
<div class="paragraph data-line-122">
<p>理論的には、チューリングマシンに基礎を置く原始的な命令型プログラミングは、<a href="https://ja.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E5%8F%AF%E8%83%BD%E6%80%A7%E7%90%86%E8%AB%96">計算可能性</a>や、<a href="https://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A3%E3%83%BC%E3%83%81%EF%BC%9D%E3%83%81%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E3%83%86%E3%83%BC%E3%82%BC">チャーチ＝チューリングのテーゼ</a>という理論により、ラムダ計算に基礎を置く関数型プログラミングと同じ、計算可能な範囲も能力も一致する、ということが証明されています。</p>
</div>
<div class="admonitionblock note data-line-127">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title"><a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church–Turing thesis</a></div>
<div class="paragraph data-line-128">
<p>1930年代に、計算可能性の概念を形式化するために、いくつかの独立した試みが行われました。</p>
</div>
<div class="ulist data-line-130">
<ul>
<li class="data-line-130">
<p>1933年、KurtGödelはJacques Herbrandとともに、一般的な再帰関数と呼ばれるクラスの正式な定義を作成しました。一般的な再帰関数のクラスは、すべての定数関数、射影、後継関数を含み、関数の合成、再帰、および最小化の下で閉じられる最小のクラスの関数（おそらく複数の引数を持つ）です。</p>
</li>
<li class="data-line-131">
<p>1936年、アロンゾチャーチは、λ計算と呼ばれる関数を定義する方法を作成しました。ラムダ計算の中で、彼はチャーチ数と呼ばれる自然数の符号化を定義しました。自然数の関数は、チャーチ数の対応する関数がλ計算の項で表すことができる場合、<strong>λ計算可能</strong>と呼ばれます。</p>
</li>
<li class="data-line-132">
<p>また、1936年、教会の仕事を学ぶ前に、アランチューリングは、テープ上の記号を操作することによって入力から計算を実行できる、現在チューリングマシンと呼ばれるマシンの理論モデルを作成しました。自然数をシンボルのシーケンスとして適切にエンコードすると、チューリングマシンがエンコードされた自然数で対応する関数を計算する場合、自然数の関数は<strong>チューリング計算可能</strong>と呼ばれます。</p>
</li>
</ul>
</div>
<div class="paragraph data-line-134">
<p><strong>ChurchとTuringは、これら3つの正式に定義された計算可能関数のクラスが一致することを証明しました。</strong>関数はTuring計算可能である場合に限り、また一般再帰的である場合にのみλ計算可能です。これにより、数学者とコンピューターサイエンティストは、計算可能性の概念がこれら3つの同等のプロセスによって正確に特徴付けられると信じるようになりました。計算可能性を特徴づける他の正式な試みは、その後、この信念を強化しました。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-137">
<p>いきなり小難しいことが並んでいるように見えますが、ここで示されている超重要な事実とは、</p>
</div>
<div class="paragraph data-line-139">
<p><strong>これまで原始的な手法として最初に習う、命令型プログラミングが扱える問題の範囲と処理能力は</strong><br>
↓<br>
<strong>これからやろうとする、関数型プログラミングが扱える問題の範囲と処理能力に等しい</strong></p>
</div>
<div class="paragraph data-line-143">
<p>ことが、数学的に証明されている、ということで、命令型プログラミングで可能だったのならば、それはすべて漏れなく関数型プログラミング<strong>だけ</strong>で実現可能です。</p>
</div>
<div class="paragraph data-line-145">
<p>この超重要な事実は、伊達や酔狂や希望的観測により主張されているのではなく、偉人らによって数学的に厳密に検証され担保されています。</p>
</div>
<div class="paragraph data-line-148">
<p>これまで曲がりなりにも、命令型プログラミングでうまくいっていたのに、これから関数型プログラミングを積極的に導入していった場合、なにかが急に出来なくなってしまう！？？という<strong>「関数型プログラミングによる理論的制限」などは存在しない</strong>、安心して大丈夫だよ？ということです。</p>
</div>
<div class="paragraph data-line-151">
<p>もういちど、スクラッチのコードを見ると、</p>
</div>
<div class="imageblock data-line-153">
<div class="content">
<img src="./img/4-7-2020-05-45-46-AM.png" alt="4 7 2020 05 45 46 AM">
</div>
</div>
<div class="paragraph data-line-155">
<p>10回繰り返す、など全体が「流れ」になっていることが確認できますが、これを３つの要素に還元したのが、</p>
</div>
<div class="paragraph data-line-157">
<p><a href="https://en.wikipedia.org/wiki/Structured_program_theorem">構造化定理(Structured program theorem)</a>です。</p>
</div>
<div class="admonitionblock note data-line-162">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Structured program theorem</div>
<div class="imageblock data-line-163">
<div class="content">
<img src="./img/4-12-2020-15-12-46-PM.png" alt="4 12 2020 15 12 46 PM">
</div>
</div>
<div class="paragraph data-line-164">
<p><em>NS図（青）とフローチャート（緑）を使用した、構造化プログラム定理の3つの基本パターン（順次、分岐１００、繰り返し）のグラフィック表現。</em></p>
</div>
<div class="paragraph data-line-166">
<p>構造化プログラムの定理、Böhm–Jacopini theoremとも呼ばれる。プログラム言語理論のひとつの帰結です。</p>
</div>
<div class="paragraph data-line-168">
<p><a href="https://en.wikipedia.org/wiki/Control-flow_graph">コントロールフローグラフ/ontrol-flow graph (CFG)</a></p>
</div>
<div class="imageblock data-line-170">
<div class="content">
<img src="./img/4-12-2020-15-26-31-PM.png" alt="4 12 2020 15 26 31 PM">
</div>
</div>
<div class="paragraph data-line-172">
<p>これは、歴史的にこの文脈では、<a href="https://en.wikipedia.org/wiki/Flowchart">フローチャート(flowcharts)</a>と呼ばれているものだが、<br>
<strong>ただ３つの特定の方法(<a href="https://en.wikipedia.org/wiki/Control_flow">コントロールフロー</a>)だけでサブプログラムを組み合わせると、<br>
いかなる計算可能な関数(<a href="https://en.wikipedia.org/wiki/Computable_function">computable function</a>)も計算できる</strong>、<br>
ということを述べています。それらは、</p>
</div>
<div class="ulist data-line-177">
<ul>
<li class="data-line-177">
<p><strong>1つのサブプログラムを実行し、次に別のサブプログラムを実行する（順次）</strong></p>
</li>
<li class="data-line-178">
<p><strong>ブール式の値に従って2つのサブプログラムのいずれかを実行する（分岐）</strong></p>
</li>
<li class="data-line-179">
<p><strong>ブール式が真である限り、サブプログラムを繰り返し実行する（反復）</strong></p>
</li>
</ul>
</div>
<div class="paragraph data-line-181">
<p>この定理は、<a href="https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">構造化プログラミング</a>の基礎を形成します。これは、gotoコマンドを避け、サブルーチン、順次、分岐、および反復を排他的に使用するプログラミングパラダイムです。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-184">
<p>構造化定理では、<strong>順次、分岐、反復の3要素だけで、いかなる計算可能な関数も計算できる、</strong>と示しているのだから、これはすなわち<a href="https://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E5%AE%8C%E5%85%A8">チューリング完全(Turing-complete)</a>あるいは、<strong>万能チューリングマシン</strong>である、と呼ばれているものと同じ意味です。</p>
</div>
<div class="paragraph data-line-186">
<p>いったん、コンピュータのプログラミング言語がチューリング完全な能力に到達すると、それ以上、原理的に計算能力が広がる、上がるなんてことはありません。チューリング完全になってるか、なってないかの二択です。</p>
</div>
<div class="paragraph data-line-188">
<p>そしてそれは、つまるところ、順次、分岐、反復の3要素がしっかり揃っているのか？ということだけで比較的容易に判別できてしまうわけです。</p>
</div>
</div>
<div class="sect2 data-line-190">
<h3 id="_まとめ">2.2. まとめ</h3>
<div class="paragraph data-line-192">
<p><strong>1.チューリングマシンに基礎を置く原始的な命令型プログラミングは、構造化プログラミングでいうと、順次、分岐、反復の3要素でフローをコントロールすると、チューリング完全となり、計算可能な範囲でなんでもできるようになる。</strong></p>
</div>
<div class="paragraph data-line-194">
<p><strong>２．チューリングマシンに基礎を置く原始的な命令型プログラミングは、ラムダ計算に基礎を置く関数型プログラミングに完全に置き換えることが可能。</strong></p>
</div>
<div class="paragraph data-line-197">
<p>従って、１と２によると、</p>
</div>
<div class="paragraph data-line-199">
<p><strong>命令型あるいは少し洗練された構造型プログラミングを脱却して、</strong><br>
<strong>関数型プログラミングを実践することは原理的に、</strong><br>
<strong>順次、分岐、反復の3要素を</strong>すべて<br>
<strong>ラムダ計算に置き換える</strong></p>
</div>
<div class="paragraph data-line-204">
<p>ということになります。</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4">
<h2 id="_文statementから式expressionへ関数型プログラミング">3. 文(statement)から式(expression)へ＝関数型プログラミング</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="sect2 data-line-15">
<h3 id="_関数型プログラミングのコードは数式">3.1. 関数型プログラミングのコードは「数式」</h3>
<div class="paragraph data-line-17">
<p>関数型プログラミングの理論的基礎となっている<a href="https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97">ラムダ計算</a>がどういうものなのか？という詳細以前に、それが「計算」というくらいなのだから<strong>「数式」である</strong>ことがわかります。</p>
</div>
<div class="paragraph data-line-19">
<p><strong>関数型プログラミングのコードは「数式」である。</strong></p>
</div>
<div class="paragraph data-line-21">
<p>これは実は巷であまり積極的には語られず、完全に過小評価されているようだが、是非、まず最初に知っておくべきたいへん重要な事実です。</p>
</div>
</div>
<div class="sect2 data-line-23">
<h3 id="_命令型プログラミングのコードは文statementの集まり">3.2. 命令型プログラミングのコードは「文(statement)」の集まり</h3>
<div class="paragraph data-line-25">
<p>他方、命令型プログラミングは、フローをコントロールするために必要なのは、その名の通り「命令文」です。式ではありません。</p>
</div>
<div class="paragraph data-line-27">
<p>命令型プログラミングのコードは「文(statement)」の集まりです。</p>
</div>
<div class="paragraph data-line-29">
<p>文（Statement）を簡潔に述べると、処理する1ステップが1つの文と言えます。 JavaScriptでは、文の末尾にセミコロン(;)を置くことで文と文に区切りをつけます。</p>
</div>
<div class="paragraph data-line-31">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements">文と宣言</a></p>
</div>
<div class="paragraph data-line-33">
<p>には、</p>
</div>
<div class="imageblock data-line-35">
<div class="content">
<img src="./img/4-12-2020-16-57-18-PM.png" alt="4 12 2020 16 57 18 PM">
</div>
</div>
<div class="imageblock data-line-37">
<div class="content">
<img src="./img/4-12-2020-16-57-50-PM.png" alt="4 12 2020 16 57 50 PM">
</div>
</div>
<div class="paragraph data-line-39">
<p>などありますが、ここでは詳細には立ち入りません。</p>
</div>
<div class="paragraph data-line-41">
<p>要するに、JavaScriptでは、デフォルトで、<br></p>
</div>
<div class="listingblock data-line-45">
<div class="title">順次処理する文のあつまり</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">statement1;
statement2;
statement3;</code></pre>
</div>
</div>
<div class="paragraph data-line-51">
<p>というように、「順次」はコードの上下に並べたら実現できるのだろうし、<br>
「分岐」「反復」については、上記のように、命令「文」が取り揃えられている、そしてそれらを構造化定理の如く、命令型プログラマーは至極あたりまえのように日常的に利用している、ということです。</p>
</div>
<div class="paragraph data-line-54">
<p>ソースコードとして書かれた文を上から順番に処理していき、適時、<code>if</code> やら <code>for</code> 文に従って分岐、反復処理を行うことでフローコントロールを実現しプログラムが実行されます。</p>
</div>
<div class="paragraph data-line-56">
<p>命令型プログラミングでも、「式」は多用されるでしょう。</p>
</div>
<div class="paragraph data-line-58">
<p>しかしながら、</p>
</div>
<div class="paragraph data-line-60">
<p><code>x = x + 1</code></p>
</div>
<div class="paragraph data-line-62">
<p>というのは「式」ぽく見えますが、すでに説明したように、</p>
</div>
<div class="paragraph data-line-64">
<p>1.メモリから値を読み取る<br>
2.値を増やします<br>
3.新しい値をメモリに書き込む</p>
</div>
<div class="paragraph data-line-68">
<p>という命令の集まりで、数学の式として眺めると、もちろん論理的に破綻しています。</p>
</div>
<div class="paragraph data-line-70">
<p>この辺はかなりテキトーにすませることが通常で、それはあとで説明するとおりそれ相応の理由もあるわけですが、このせいで多大な混乱をプログラミングにもたらせています。非常に問題です。</p>
</div>
</div>
<div class="sect2 data-line-73">
<h3 id="_1_2_3二項演算を軸とした関数型プログラミングのコード">3.3. 1 + 2 = 3　二項演算を軸とした関数型プログラミングのコード</h3>
<div class="paragraph data-line-75">
<p>他方で、関数型プログラミングのコードは、式＝expressionの集まりと言えます。</p>
</div>
<div class="paragraph data-line-77">
<p>そして式は値であり、フローに従って時間発展しません。</p>
</div>
<div class="paragraph data-line-79">
<p><strong>関数型プログラミングのコードは「数式」である。</strong></p>
</div>
<div class="paragraph data-line-81">
<p>では関数型のコードは具体的にどんな「数式」になっているのでしょうか？</p>
</div>
<div class="paragraph data-line-85">
<p>プログラマーのみならず、義務教育の算数で誰でも習う</p>
</div>
<div class="paragraph data-line-87">
<p>\(1 + 2 = 3\)</p>
</div>
<div class="paragraph data-line-89">
<p>は、<a href="https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E6%BC%94%E7%AE%97">二項演算</a>、英語では<a href="https://en.wikipedia.org/wiki/Binary_operation">binary operation</a>と呼ばれています。</p>
</div>
<div class="literalblock data-line-91">
<div class="content">
<pre>数学において、二項演算（binary operation）は、数の四則演算（加減乗除）などの 「二つの数から新たな数を決定する規則」 を一般化した概念である。</pre>
</div>
</div>
</div>
<div class="sect2 data-line-93">
<h3 id="_二項演算は2つの引数をとる関数">3.4. 二項演算は2つの引数をとる関数</h3>
<div class="paragraph data-line-95">
<p>二項演算という算術は小学生でも誰でも知っている概念ですが、多くのプログラマーが知らず、意識したことがないこととは、この<strong>「二つの数から新たな数を決定する規則」</strong>というものが実は、<strong>2つの引数をとる関数</strong>であるという事実です。</p>
</div>
<div class="paragraph data-line-97">
<p><em>関数そして二項演算そのもの厳密な数学の説明は、土台から積み上げるとここまで到達するまでに分量が多いので、🟧 <strong>UNIT 3 : 数学 Mathematics</strong> へ切り分けています。</em></p>
</div>
<div class="imageblock data-line-99">
<div class="content">
<img src="./img/1-12-2020-13-07-41-PM.png" alt="1 12 2020 13 07 41 PM">
</div>
</div>
<div class="paragraph data-line-101">
<p><a href="https://en.wikipedia.org/wiki/Binary_operation">binary operation</a>にあるこの図は、<strong>2つの引数をとる関数</strong>そのもので、<code>○</code> として表現されているもの、</p>
</div>
<div class="paragraph data-line-103">
<p>\(1 + 2 = 3\)</p>
</div>
<div class="paragraph data-line-105">
<p>の場合、<code>+</code> は、<strong>二項演算子/binary operator</strong>と呼ばれています。</p>
</div>
<div class="paragraph data-line-107">
<p><a href="https://ja.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E5%AD%90">演算子</a></p>
</div>
<div class="literalblock data-line-109">
<div class="content">
<pre>数学的には、基本的には、関数（単項演算子では1引数の関数、2項演算子は2引数の関数）をあらわすある種の糖衣構文のようなものに過ぎない。</pre>
</div>
</div>
<div class="paragraph data-line-111">
<p><a href="https://en.wikipedia.org/wiki/Operator_(mathematics)">Operator (mathematics)</a></p>
</div>
<div class="literalblock data-line-113">
<div class="content">
<pre>In mathematics, an operator is generally a mapping or function that acts on elements of a space to produce elements of another space (possibly the same space, sometimes required to be the same space). There is no general definition of an operator, but the term is often used in place of function when the domain is a set of functions or other structured objects. +
数学では、演算子とは一般に、空間の要素に作用して別の空間の要素を生成する写像や関数のことを指します（同じ空間である場合もあれば、同じ空間であることが要求される場合もあります）。演算子の一般的な定義はありませんが、ドメインが関数やその他の構造化されたオブジェクトの集合である場合、関数の代わりにこの用語がよく使われます。</pre>
</div>
</div>
<div class="paragraph data-line-116">
<p><a href="https://www.britannica.com/topic/operator" class="bare">https://www.britannica.com/topic/operator</a></p>
</div>
<div class="literalblock data-line-118">
<div class="content">
<pre>Operator, in mathematics, any symbol that indicates an operation to be performed. Examples are Square root of√x (which indicates the square root is to be taken) and d/dx (which indicates differentiation with respect to x is to be performed). An operator may be regarded as a function, transformation, or map, in the sense that it associates or “maps” elements from one set to elements from another set. +
演算子、数学では、実行されるべき演算を示す任意の記号。例としては、√xの平方根（平方根を取ることを示す）やd/dx（xに対する微分が実行されることを示す）などがある。演算子は、ある集合の要素を別の集合の要素に関連付ける、または「写像」するという意味で、関数、変換、または写像とみなされることがある。</pre>
</div>
</div>
<div class="paragraph data-line-121">
<p>つまり、<strong>演算子(operator)は、記号であったり、書かれている位置が異なるだけ(<a href="https://ja.wikipedia.org/wiki/%E4%B8%AD%E7%BD%AE%E8%A8%98%E6%B3%95">中置記法</a>)の、関数の別の表現方法</strong>なのです。</p>
</div>
<div class="paragraph data-line-123">
<p>JavaScriptでもECMAScript2016の新しい仕様として、<br>
<code>Math.pow()</code> と等価の<br>
<strong>べき乗演算子(Exponentiation Operator)</strong> <code>**</code>
が導入された、ということも実際あります。</p>
</div>
<div class="paragraph data-line-128">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Exponentiation" class="bare">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Exponentiation</a></p>
</div>
<div class="listingblock data-line-133">
<div class="title">2の3乗算</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">Math.pow(2, 3); // 8

2 ** 3; // 8</code></pre>
</div>
</div>
<div class="listingblock data-line-141">
<div class="title">演算子の結合</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">2 ** 3 ** 2   // 512
2 ** (3 ** 2) // 512
(2 ** 3) ** 2 // 64</code></pre>
</div>
</div>
<div class="paragraph data-line-147">
<p>べき乗演算子(Exponentiation Operator) <code>**</code> の記法をみると、<code>Math.pow()</code> 関数を使うよりかは、どうもこちらのほうが簡潔にコードが書けてしまい、意味もわかりやすく、結合順序も容易にコントロールできそうなことが感じられます。</p>
</div>
</div>
<div class="sect2 data-line-149">
<h3 id="_関数をfxとする記法はbestではない">3.5. 関数をf(x)とする記法はBestではない</h3>
<div class="paragraph data-line-151">
<p>今これとは逆に、既存の足し算の演算子である <code>+</code> という二項演算子を、2引数の関数 <code>plus</code> に変換する作業をしてみましょう。</p>
</div>
<div class="listingblock data-line-155">
<div class="title">plus関数の定義</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const plus = (a, b) =&gt; a + b;</code></pre>
</div>
</div>
<div class="listingblock data-line-161">
<div class="title">plus関数をつかう</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    console.log(
      1 + 2
    ); // 3

    console.log(
      plus(1, 2)
    ); // 3</code></pre>
</div>
</div>
<div class="paragraph data-line-171">
<p><code>+</code> 演算子の代わりに <code>plus</code> 関数を1つだけ使う分には、まあさほど問題はないように見えます。</p>
</div>
<div class="listingblock data-line-175">
<div class="title">plus関数をもっとつかう</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    console.log(
      1 + 2 + 3 + 4
    ); // 10

    console.log(
      plus(plus(plus(1, 2), 3), 4)
    ); // 10</code></pre>
</div>
</div>
<div class="paragraph data-line-185">
<p>しかし、我々が算数の授業で慣れ親しんでいる至極単純な数式 <code>1 + 2 + 3 + 4</code> では、JavaScriptで一般的な関数の書き方をするとネストしてしまい酷いことになっています。</p>
</div>
<div class="paragraph data-line-187">
<p>とりあえずここでわかることは、おそらく中学校の数学の授業で習った関数表記、</p>
</div>
<div class="paragraph data-line-189">
<p>\(f(x)\)</p>
</div>
<div class="paragraph data-line-191">
<p>あるいは、JavaScriptプログラミングで一般的な記法、</p>
</div>
<div class="imageblock data-line-193">
<div class="content">
<img src="./img/6-7-2020-21-26-22-PM.png" alt="6 7 2020 21 26 22 PM">
</div>
</div>
<div class="paragraph data-line-194">
<p><code>f(x)</code> は、けしてBestではない、ということです。</p>
</div>
<div class="paragraph data-line-196">
<p>むしろ二項演算が連鎖する局面、それは実際、特に関数型プログラミングではめちゃくちゃ多くなるわけですが、その際はネストしまくってメンテナンスが極めて困難になり収集がつかなくなるので有害であり避けるべきです。</p>
</div>
</div>
<div class="sect2 data-line-198">
<h3 id="_ユーザ定義が可能な演算子">3.6. ユーザ定義が可能な演算子</h3>
<div class="paragraph data-line-200">
<p>純粋関数型言語のHaskellでは流石にこの辺はよくわかっていて、二項演算子を前置形式の関数にできたり、その逆が自由に、臨機応変に可能です。</p>
</div>
<div class="paragraph data-line-202">
<p>中置演算子 を <code>()</code> で囲むことで、前置形式の関数として記述できます。</p>
</div>
<div class="listingblock data-line-206">
<div class="title">(Haskell) 加算</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">Prelude&gt; 3 + 2
5

Prelude&gt; (+) 3 2
5</code></pre>
</div>
</div>
<div class="paragraph data-line-214">
<p>前置形式の関数を <code>`(backquote)</code> で囲むことで、中置演算子として記述できます。</p>
</div>
<div class="listingblock data-line-218">
<div class="title">(Haskell) 除算の余りを求めるmod関数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">Prelude&gt; mod 3 2
1

Prelude&gt; 3 `mod` 2
1</code></pre>
</div>
</div>
<div class="paragraph data-line-226">
<p>このようにHaskellでは、関数を中置演算子にかんたんに変換できることもふくめ、任意の記号を使った演算子のユーザ定義が可能です。</p>
</div>
<div class="paragraph data-line-228">
<p>プログラミング界隈では一般に、<a href="https://ja.wikipedia.org/wiki/%E5%88%A9%E7%94%A8%E8%80%85%E5%AE%9A%E7%BE%A9%E6%BC%94%E7%AE%97%E5%AD%90">ユーザ定義演算子</a>や<a href="https://en.wikipedia.org/wiki/Operator_overloading">演算子のオーバーロード</a>とも呼ばれています。</p>
</div>
<div class="paragraph data-line-230">
<p>これはすでに説明したとおり、関数型プログラミングでは極めて重要なのですが、非常に残念なことに<strong>JavaScriptでは演算子をユーザ定義できるような機能が存在していません。</strong></p>
</div>
<div class="paragraph data-line-232">
<p>当然の帰結として、巷にあふれるJavaScriptの関数型のコードは、Haskellプログラマーが書く簡潔なコード、つまり自由自在に二項演算子＝中置演算子を駆使しているようなコードと比較すると、回りくどく見にくいコードに仕上がっています。</p>
</div>
<div class="paragraph data-line-234">
<p>個人的には「それは仕様なので仕方ない」とは済ませず、本書ではそのようなコードは受容しない、ということで、JavaScriptでも演算子のユーザ定義をできるように簡単なハックをします。</p>
</div>
</div>
<div class="sect2 data-line-236">
<h3 id="_オブジェクト指向と二項演算の意外な関係性">3.7. オブジェクト指向と二項演算の意外な関係性</h3>
<div class="paragraph data-line-238">
<p>ここで、オブジェクト指向です。</p>
</div>
<div class="paragraph data-line-240">
<p>JavaScriptはオブジェクト指向と関数型のハイブリッド言語です。</p>
</div>
<div class="admonitionblock tip data-line-245">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">JavaScriptがオブジェクト指向と関数型のハイブリッド言語になった歴史的経緯</div>
<div class="paragraph data-line-246">
<p>JavaScriptの生みの親である<a href="https://ja.wikipedia.org/wiki/%E3%83%96%E3%83%AC%E3%83%B3%E3%83%80%E3%83%B3%E3%83%BB%E3%82%A2%E3%82%A4%E3%82%AF">ブレンダン・アイク(Brendan Eich)</a>は<a href="https://brendaneich.com/2008/04/popularity/">ご自身のブログポスト</a>には、<em>Nick Thompson had turned me on to <a href="http://mitpress.mit.edu/sicp/">SICP</a>.</em> など、その他にも関数型言語についての記載があります。</p>
</div>
<div class="paragraph data-line-248">
<p>本書でも後で引用することになるSICP(<a href="https://ja.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A7%A3%E9%87%88">計算機プログラムの構造と解釈</a>)は関数型プログラミングの古典的な名著であり、彼はその本でも使われているSchemeという関数型言語のプログラマーでした。</p>
</div>
<div class="paragraph data-line-250">
<p>NetscapeNavigatorブラウザに組み込むスクリプト言語の開発者としてNetscape社にリクルートされた彼は、Schemeをスクリプト言語として採用する、という約束だったのですが、入社当時、新進気鋭のJavaというオブジェクト指向言語の人気の高まりの影響で会社のマーケティング上の理由から上司に、スクリプト言語は「Javaのように見える」必要があると命令されました。</p>
</div>
<div class="paragraph data-line-252">
<p>結果、彼が開発したブラウザスクリプト言語はJavaっぽいネーミングとなり、Javaっぽいオブジェクト指向と、Schemeぽいファーストクラスの関数を備えた関数型のハイブリッドとなったのです。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-255">
<p>JavaScriptオブジェクトには、例にもれず、メソッドと呼ばれるオブジェクトに組み込まれている関数があります。</p>
</div>
<div class="paragraph data-line-257">
<p>メソッドの中には引数を取るものがあります。例えば</p>
</div>
<div class="paragraph data-line-259">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/concat">String.prototype.concat()</a></p>
</div>
<div class="listingblock data-line-263">
<div class="title">String.concatメソッド 文字列の接続</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  console.log(
    "ab".concat("c")
  );　// abc</code></pre>
</div>
</div>
<div class="paragraph data-line-269">
<p>これはご覧のとおり、String <code>"ab"</code> と <code>"c"</code> を接続する関数なので、</p>
</div>
<div class="listingblock data-line-273">
<div class="title">"ab" + "c" = "abc" 文字列の接続</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  console.log(
    "ab" + "c"
  ); // abc</code></pre>
</div>
</div>
<div class="paragraph data-line-279">
<p>と同じ意味です。そしてよく見比べてみると、</p>
</div>
<div class="paragraph data-line-281">
<p><code>.concat</code> メソッドがちょうど <code>+</code> 演算子と同じ位置で対応していて、中置の演算子として機能しています。</p>
</div>
<div class="paragraph data-line-283">
<p>つまり、これは文字列同士を接続する<strong>二項演算</strong>にほかならず、実は、1引数をとるメソッドは、すべて</p>
</div>
<div class="paragraph data-line-285">
<p><strong>オブジェクトの値　&lt;メソッド&gt;　(その引数)</strong></p>
</div>
<div class="paragraph data-line-287">
<p>という形式の二項演算になっています。</p>
</div>
<div class="paragraph data-line-290">
<p>JavaScriptのメソッドは、都合の良いことに、連想配列の形式でも表現できるので、</p>
</div>
<div class="listingblock data-line-293">
<div class="title">String.concatメソッド 文字列の接続</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  console.log(
    "ab".concat("c")
  ); // abc

  console.log(
    "ab"[`concat`]("c")
  ); // abc</code></pre>
</div>
</div>
<div class="paragraph data-line-303">
<p>と書き換えたならば、オブジェクト指向っぽさは消え失せ、Haskellの二項演算の中置演算子ぽい表記になっていることに気が付きます。</p>
</div>
<div class="listingblock data-line-307">
<div class="title">(Haskell) 除算の余りを求めるmod関数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">Prelude&gt; mod 3 2
1

Prelude&gt; 3 `mod` 2
1</code></pre>
</div>
</div>
<div class="paragraph data-line-315">
<p>更に、都合のよいことに、JavaScriptの既存のオブジェクトのメソッドは
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a>で簡単に拡張できます。</p>
</div>
<div class="paragraph data-line-318">
<p>ということで、任意の型(type)＝集合(set)＝オブジェクト(object)(<em>🟧 <strong>UNIT 3 : 数学 Mathematics</strong>参照</em>)に紐づいている二項演算の中置演算子を、任意の文字列(記号もOK！)でユーザ定義できる関数を以下のとおり用意してやることができるでしょう。</p>
</div>
<div class="listingblock data-line-322">
<div class="title">JavaScript演算子のユーザ定義のための関数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  const customOperator = op =&gt; f =&gt; set =&gt;
      Object.defineProperty(set, op, {
        value: function (a) {
          return f(a)(this);
        }
      });//returns new set/object</code></pre>
</div>
</div>
<div class="listingblock data-line-333">
<div class="title">TypeScript演算子のユーザ定義のための関数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  const customOperator =
    (op: string) =&gt;
      (f: Function) =&gt;
        (set: Object) =&gt;
          Object.defineProperty(set, op, {
            value: function (a: unknown) {
              return f(a)(this);
            }
          });//returns new set/object</code></pre>
</div>
</div>
<div class="paragraph data-line-345">
<p><code>this</code> はオブジェクト指向言語としてのJavaScriptへ混入された混乱とバグの原因なのですが、本書では扱うのはこれっきりで、このJavaScriptのオブジェクト指向としてのドット記法を利用したハック関数のなかに押し込めてしまいます。</p>
</div>
<div class="listingblock data-line-349">
<div class="title">JavaScript演算子のユーザ定義の例 +(プラス)演算子の再発明</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs"> //カリー化した　plus 高階関数
    const plus =
      b =&gt;
        a =&gt; a + b;
　// plus関数の挙動の確認
    console.log(
      plus(2)(1)
    ); // 3
　// `+` 演算子をユーザ定義　plus関数の定義域としてNumberプロトタイプ集合へ紐付ける
    customOperator(`+`)
      (plus)
      (Number.prototype);

    console.log(
        (1)[`+`](2)
    );　// 3</code></pre>
</div>
</div>
<div class="paragraph data-line-368">
<p>JavaScriptであっても、</p>
</div>
<div class="paragraph data-line-370">
<p><code>plus</code> など自由に定義した関数から</p>
</div>
<div class="paragraph lead data-line-372">
<p>(1)[`+`](2)</p>
</div>
<div class="paragraph data-line-374">
<p>と　<code>+</code> など、記号を含む自由な文字列で中置演算子をユーザ定義できるようになりました。</p>
</div>
<div class="paragraph data-line-376">
<p><em>カリー化したplus高階関数、関数の定義域、集合、などについては、🟧 <strong>UNIT 3 : 数学 Mathematics</strong>参照</em></p>
</div>
<div class="paragraph data-line-378">
<p>さて、ここまでで<br>
二項演算の演算子は実は、2引数をとる関数のことで、相互に変換可能である、ことを確認しました。</p>
</div>
<div class="imageblock data-line-381">
<div class="content">
<img src="./img/1-12-2020-20-50-38-PM.png" alt="1 12 2020 20 50 38 PM">
</div>
</div>
<div class="paragraph data-line-383">
<p>さらにJavaScriptで二項演算子を自由に定義可能が可能であることを確認しました。</p>
</div>
</div>
<div class="sect2 data-line-386">
<h3 id="_関数function値value">3.8. 関数(function)=値(value)</h3>
<div class="imageblock data-line-388">
<div class="content">
<img src="./img/1-12-2020-10-23-16-AM.png" alt="1 12 2020 10 23 16 AM">
</div>
</div>
<div class="paragraph data-line-390">
<p>関数型プログラミングが可能な言語では、関数(function)は<a href="https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E9%96%A2%E6%95%B0">第一級関数</a>/<a href="https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88">第一級オブジェクト</a>(<a href="https://en.wikipedia.org/wiki/First-class_function">first-class function</a>)となっていて、値(value)として自由自在に取り回せます。</p>
</div>
</div>
<div class="sect2 data-line-392">
<h3 id="_式expresssion値value">3.9. 式(expresssion)=値(value)</h3>
<div class="paragraph data-line-394">
<p>式(expresssion)=値(value)です。</p>
</div>
</div>
<div class="sect2 data-line-396">
<h3 id="_二項演算を軸とした関数型プログラミングのコードの全体像">3.10. 二項演算を軸とした関数型プログラミングのコードの全体像</h3>
<div class="paragraph data-line-398">
<p><span class="image"><img src="./img/1-12-2020-07-38-22-AM.png" alt="1 12 2020 07 38 22 AM"></span></p>
</div>
<div class="paragraph data-line-401">
<p>そして、関数も式を構成する値になるので、</p>
</div>
<div class="imageblock data-line-403">
<div class="content">
<img src="./img/1-12-2020-09-15-55-AM.png" alt="1 12 2020 09 15 55 AM">
</div>
</div>
<div class="paragraph data-line-405">
<p>3要素に値か関数か2択なので、2の3乗で全部で8通りのパターンがあるわけですが、主に使い倒すのは上記の4パターンだけです。</p>
</div>
<div class="paragraph data-line-407">
<p>残りの4パターン、たとえば、</p>
</div>
<div class="imageblock data-line-409">
<div class="content">
<img src="./img/1-12-2020-09-23-48-AM.png" alt="1 12 2020 09 23 48 AM">
</div>
</div>
<div class="paragraph data-line-411">
<p>などは、利用の可能性を排除するわけではありませんが、上記の4パターンがかなり強力で汎用的なので、ほぼほぼこれらを使い倒すことになります。</p>
</div>
</div>
<div class="sect2 data-line-414">
<h3 id="_式expression値value関数functionが再び式の要素になる関数型コード">3.11. 式(expression)＝値(value)/関数(function)が再び式の要素になる=関数型コード</h3>
<div class="paragraph data-line-416">
<p><strong>式(expression)＝値(value)/関数(function)が再び式の要素になる</strong></p>
</div>
<div class="paragraph data-line-418">
<p>それが関数型プログラミングのコードであり、<strong>関数型プログラミングの定義と考えて良い</strong>でしょう。</p>
</div>
<div class="paragraph data-line-420">
<p>そして、式の値をまた別の式に投入していくと、式と式との間に依存関係が構築されていきます。</p>
</div>
<div class="paragraph data-line-422">
<p>小1の算数では、こういう算術を習いました。</p>
</div>
<div class="imageblock data-line-424">
<div class="content">
<img src="./img/1-12-2020-11-20-54-AM.png" alt="1 12 2020 11 20 54 AM">
</div>
</div>
<div class="paragraph data-line-426">
<p>これは先程の図法に描き直すと、</p>
</div>
<div class="imageblock data-line-428">
<div class="content">
<img src="./img/1-12-2020-10-57-49-AM.png" alt="1 12 2020 10 57 49 AM">
</div>
</div>
<div class="paragraph data-line-430">
<p>これは次の式とおなじにできる。</p>
</div>
<div class="imageblock data-line-432">
<div class="content">
<img src="./img/1-12-2020-10-59-33-AM.png" alt="1 12 2020 10 59 33 AM">
</div>
</div>
<div class="paragraph data-line-435">
<p>別の重要なパターンを示すと</p>
</div>
<div class="imageblock data-line-437">
<div class="content">
<img src="./img/1-12-2020-11-01-43-AM.png" alt="1 12 2020 11 01 43 AM">
</div>
</div>
<div class="paragraph data-line-439">
<p>これは次の式とおなじにできる。</p>
</div>
<div class="imageblock data-line-441">
<div class="content">
<img src="./img/1-12-2020-11-02-17-AM.png" alt="1 12 2020 11 02 17 AM">
</div>
</div>
<div class="paragraph data-line-444">
<p>もちろん、</p>
</div>
<div class="imageblock data-line-446">
<div class="content">
<img src="./img/1-12-2020-10-23-16-AM.png" alt="1 12 2020 10 23 16 AM">
</div>
</div>
<div class="paragraph data-line-448">
<p>なので、</p>
</div>
<div class="imageblock data-line-450">
<div class="content">
<img src="./img/1-12-2020-11-05-33-AM.png" alt="1 12 2020 11 05 33 AM">
</div>
</div>
<div class="paragraph data-line-452">
<p>という式の連鎖は、</p>
</div>
<div class="imageblock data-line-454">
<div class="content">
<img src="./img/1-12-2020-11-10-10-AM.png" alt="1 12 2020 11 10 10 AM">
</div>
</div>
<div class="paragraph data-line-456">
<p>となります。</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4">
<h2 id="_複雑さとの闘いのための最終兵器結合性">4. 複雑さとの闘いのための最終兵器＝結合性</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="sect2 data-line-15">
<h3 id="_コーディングは複雑さとの闘い">4.1. コーディングは複雑さとの闘い</h3>
<div class="paragraph data-line-17">
<p>コーディングは複雑さとの闘いです。</p>
</div>
<div class="paragraph data-line-19">
<p>その最終兵器となるものが、結合性である、というもっとも重要な話をします。</p>
</div>
<div class="imageblock data-line-21">
<div class="content">
<img src="./img/4-12-2020-17-32-03-PM.png" alt="4 12 2020 17 32 03 PM">
</div>
</div>
<div class="paragraph data-line-23">
<p>こうなると説明しました。</p>
</div>
<div class="paragraph data-line-25">
<p>素晴らしいことのように思えます。</p>
</div>
<div class="imageblock data-line-27">
<div class="content">
<img src="./img/4-12-2020-17-34-42-PM.png" alt="4 12 2020 17 34 42 PM">
</div>
</div>
<div class="paragraph data-line-29">
<p>ではこれは同じでしょうか？</p>
</div>
<div class="paragraph data-line-31">
<p>いい加減まどろっこしくなってきたので、数式に戻しましょう。</p>
</div>
<div class="paragraph data-line-33">
<p>\((1 + 2) + 3 = 1 + 2 + 3\)</p>
</div>
<div class="paragraph data-line-35">
<p>です。では、</p>
</div>
<div class="paragraph data-line-37">
<p>\(1 + 2 + 3 = 1 + (2 + 3)\)</p>
</div>
<div class="paragraph data-line-39">
<p>なのか？</p>
</div>
<div class="paragraph data-line-41">
<p>この場合、もちろんそうで、</p>
</div>
<div class="paragraph data-line-43">
<p>\((1 + 2) + 3 = 1 + 2 + 3 = 1 + (2 + 3)\)</p>
</div>
<div class="paragraph data-line-45">
<p>が成り立っています。</p>
</div>
<div class="paragraph data-line-47">
<p><span class="image"><img src="./img/1-7-2020-09-05-29-AM.png" alt="1 7 2020 09 05 29 AM"></span></p>
</div>
<div class="paragraph data-line-49">
<p>これは()で決まる、計算の順序によって値は異る！？というようなことはない、同じになる、ということで、<br>
<strong>結合性(associativity)がある、あるいは、結合法則(associative law)が成り立っている</strong>、などと言い表します。</p>
</div>
<div class="admonitionblock note data-line-54">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title"><a href="https://ja.wikipedia.org/wiki/%E7%B5%90%E5%90%88%E6%B3%95%E5%89%87">結合法則(associative law)</a></div>
<div class="paragraph data-line-55">
<p>二項演算が結合的ならば、その演算が反復して適用されるとき、その式においてきちんと（開きと閉じが）対になる括弧がどのように挿入されるかを気にすることなく、その演算結果が同じであることがわかる。そのことを一般化された結合法則 (generalized associative law) と言う。実例として、四つの元の積を、それらの因子の順番を変えることなく書き下せば、五種類の異なる計算順序が考えられる:</p>
</div>
<div class="paragraph data-line-57">
<p>\(((ab)c)d\)</p>
</div>
<div class="paragraph data-line-59">
<p>\((ab)(cd)\)</p>
</div>
<div class="paragraph data-line-61">
<p>\((a(bc))d\)</p>
</div>
<div class="paragraph data-line-63">
<p>\(a((bc)d)\)</p>
</div>
<div class="paragraph data-line-65">
<p>\(a(b(cd))\)</p>
</div>
<div class="paragraph data-line-67">
<p>が、これらの積を得る演算が結合的ならば、一般化された結合法則の述べるに従い、これらすべてが同じ値の積であることが結論される。となれば（これらの式から括弧をすべて取り払った式に既に別の意味が施されているのでない限り）この積において括弧は「不要」のものと考えることができて、この積を紛れの虞なく</p>
</div>
<div class="paragraph data-line-69">
<p>\(abcd\)</p>
</div>
<div class="paragraph data-line-71">
<p>と書くことができる。</p>
</div>
<div class="paragraph data-line-73">
<p><strong>このような繰り返しの積において、因子となる元の数が増えるにしたがって、釣り合いのとれた括弧の挿入の仕方の総数は急速に増加するけれども、演算が結合的ならばそれらの区別もやはり必要がなくなる。</strong></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-76">
<p>重要なのは、最後の文章で、「もしも結合法則が成り立ってなかったら」カッコの挿入の仕方の総数が急速に増加する、という点です。</p>
</div>
<div class="paragraph data-line-78">
<p>つまり、非常に初歩的な二項演算のレベルにおいて、すでに、</p>
</div>
<div class="paragraph data-line-80">
<p><a href="https://ja.wikipedia.org/wiki/%E7%B5%84%E5%90%88%E3%81%9B%E7%88%86%E7%99%BA">組み合わせ爆発</a></p>
</div>
<div class="paragraph data-line-82">
<p>というようなものが巻き起こってしまう、ということです。</p>
</div>
<div class="paragraph data-line-84">
<p>掛け算には結合性があって、カッコのありなしによって決まる計算順序は気にする必要はなく、\(abcd\)とだけ書けば良い、組み合わせ爆発は起こらないだろう、ということです。</p>
</div>
</div>
<div class="sect2 data-line-87">
<h3 id="_monoidモノイド">4.2. Monoid(モノイド)</h3>
<div class="imageblock data-line-89">
<div class="content">
<img src="./img/0-12-2020-20-35-19-PM.png" alt="0 12 2020 20 35 19 PM">
</div>
</div>
<div class="paragraph data-line-91">
<p>こういう二項演算で結合性がある、つまり、</p>
</div>
<div class="imageblock data-line-93">
<div class="content">
<img src="./img/1-12-2020-10-59-33-AM.png" alt="1 12 2020 10 59 33 AM">
</div>
</div>
<div class="paragraph data-line-95">
<p>このように連鎖させたとき、（）がどこかについて計算順序がどんなふうに変えられたとしても、結果は同じになる、組み合わせ爆発など起こらない、複雑さの懸念がない、二項演算のことを、モノイドと呼びます。</p>
</div>
<div class="paragraph data-line-97">
<p>厳密には</p>
</div>
<div class="paragraph data-line-99">
<p><a href="https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8E%E3%82%A4%E3%83%89">モノイド</a></p>
</div>
<div class="paragraph data-line-101">
<p><span class="image"><img src="./img/0-12-2020-20-43-23-PM.png" alt="0 12 2020 20 43 23 PM"></span></p>
</div>
<div class="paragraph data-line-103">
<p>とかいろいろあるのですが、それは再度繰り返しとなりますが、<em>厳密な数学の説明は、土台から積み上げるとここまで到達するまでに分量が多いので、🟧 <strong>UNIT 3 : 数学 Mathematics</strong> へ切り分けています。</em></p>
</div>
<div class="paragraph data-line-105">
<p>ここでは、もっとも重要なのはあくまで<strong>結合性</strong>であり、代数構造のなかで特別視される重要な構造です。さらにいうと、単位元は、結合性さえあれば、後から絶対に、というか簡単に追加できるので、単位元のあるなしはろくに区別されていないということもあります。（この説明も後回しですっとばします）</p>
</div>
</div>
<div class="sect2 data-line-107">
<h3 id="_レゴブロックは_monoidモノイド">4.3. レゴブロックは Monoid(モノイド)</h3>
<div class="paragraph data-line-109">
<p>数式ではなくもっと身近な事例を考えることもできます。</p>
</div>
<div class="paragraph data-line-111">
<p>たとえば、レゴブロックを考えてみましょう。</p>
</div>
<div class="imageblock data-line-113">
<div class="content">
<img src="./img/4-12-2020-18-02-16-PM.png" alt="4 12 2020 18 02 16 PM">
</div>
</div>
<div class="paragraph data-line-115">
<p>レゴブロックには結合性があります。結合法則を満たしている。</p>
</div>
<div class="paragraph data-line-118">
<p>\((レゴブロックA + レゴブロックB) + レゴブロックC\)</p>
</div>
<div class="paragraph data-line-120">
<p>\(レゴブロックA + (レゴブロックB + レゴブロックC)\)</p>
</div>
<div class="paragraph data-line-122">
<p>\(レゴブロックA + レゴブロックB + レゴブロックC\)</p>
</div>
<div class="paragraph data-line-124">
<p>上の接続パターンは結果同じになる、ということです。結合性がある。</p>
</div>
<div class="paragraph data-line-126">
<p>同じ構成でさえあれば、それがどういう順番で組み立てられようが結果は同じになります。</p>
</div>
<div class="paragraph data-line-128">
<p>これがもし、こっちのパーツを先に組み立ててからでないと、別のパーツと組み立てるタイミングが異なれば、別のものになってしまう。。。とかだったら、もう面倒臭すぎるでしょう。</p>
</div>
</div>
<div class="sect2 data-line-130">
<h3 id="_usb機器はmonoidモノイド">4.4. USB機器はMonoid(モノイド)</h3>
<div class="paragraph data-line-132">
<p>同じことはUSB機器にも言えます。</p>
</div>
<div class="imageblock data-line-134">
<div class="content">
<img src="./img/4-12-2020-18-06-58-PM.png" alt="4 12 2020 18 06 58 PM">
</div>
</div>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=kenec201702-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B07ST84PF5&linkId=d0b732b63dcc2116b7354a17d0ea7169"></iframe>
<div class="paragraph data-line-140">
<p>USB機器には結合性があります。結合法則を満たしている。</p>
</div>
<div class="paragraph data-line-142">
<p>USB機器を接続するときは、レゴと一緒で、どういう順番につながないと、目的の構成にならない！という面倒なことはありません。</p>
</div>
<div class="paragraph data-line-144">
<p>たとえば、</p>
</div>
<div class="paragraph data-line-146">
<p>USBハブをPCに接続してから、USBハブになにかUSB機器を接続する<br>
USBハブにUSB機器を接続してから、USBハブをPCに接続する</p>
</div>
<div class="paragraph data-line-149">
<p>これは同じ構成になる、ということは皆知っているでしょう。</p>
</div>
<div class="paragraph data-line-151">
<p>結合性があるって素晴らしいですね。<br>
逆に結合性がない規格は非常に取り扱いの面倒なものになります。組み合わせ爆発が起こるわけで、まず使い物にはならないでしょう。</p>
</div>
<div class="paragraph data-line-154">
<p>\((PCのUSB端子 + USBハブ) + USB機器\)</p>
</div>
<div class="paragraph data-line-156">
<p>\(PCのUSB端子 + (USBハブ + USB機器)\)</p>
</div>
<div class="paragraph data-line-158">
<p>\(PCのUSB端子 + USBハブ + USB機器\)</p>
</div>
<div class="paragraph data-line-160">
<p>規格で一般化した表現にすると、</p>
</div>
<div class="paragraph data-line-163">
<p>\((USB機器 + USB機器) + USB機器\)</p>
</div>
<div class="paragraph data-line-165">
<p>\(USB機器 + (USB機器 + USB機器)\)</p>
</div>
<div class="paragraph data-line-167">
<p>\(USB機器 + USB機器 + USB機器\)</p>
</div>
<div class="paragraph data-line-169">
<p>上の接続パターンは結果同じ機器になる、ということです。結合性がある。</p>
</div>
</div>
<div class="sect2 data-line-171">
<h3 id="_文字列はmonoidモノイド">4.5. 文字列はMonoid(モノイド)</h3>
<div class="paragraph data-line-174">
<p>同じように、文章、文字列、というのも結合性があります。</p>
</div>
<div class="paragraph data-line-176">
<p>\(("結合性" + "が") + "ある"\)</p>
</div>
<div class="paragraph data-line-178">
<p>\("結合性" + ("が" + "ある")\)</p>
</div>
<div class="paragraph data-line-180">
<p>\("結合性" + "が" + "ある"\)</p>
</div>
<div class="paragraph data-line-182">
<p>つまり、</p>
</div>
<div class="paragraph data-line-184">
<p>\((文字列 + 文字列) + 文字列\)</p>
</div>
<div class="paragraph data-line-186">
<p>\(文字列 + (文字列 + 文字列)\)</p>
</div>
<div class="paragraph data-line-188">
<p>\(文字列 + 文字列 + 文字列\)</p>
</div>
<div class="paragraph data-line-190">
<p>文字列に結合性があって良かったです。もし文字列に結合性がなければ、コピペ、カットペーストの順番によって別の文章が出来上がるわけで、引用すらおちおちできず、組み合わせ爆発がおこり、我々の現代文明に致命的な悪影響を及ぼしていたことでしょう。</p>
</div>
<div class="paragraph data-line-192">
<p>このように非常に低レベルな二項演算だけでも、恐ろしい複雑性と戦うためには、扱う対象に結合性をもたせておく、というのは死活問題です。</p>
</div>
<div class="paragraph data-line-194">
<p>関数型プログラミングを実践するにあたり、結合性は最重要視され、最優先事項となります。</p>
</div>
<div class="paragraph data-line-196">
<p>つまり、関数型プログラミングの式は、二項演算が中心となりますが、その値と二項演算子のペアは結合性を満たすものを特別待遇し、合理的理由がないかぎり、結合性のないものは可能な限り排除します。理由もないのに結合性を満たさない式を構築すると、組み合わせ爆発が起こってしまい、コントロール不能になってしまうからです。</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4">
<h2 id="_値と演算と関数と定義域のはなし型は集合_types_as_sets">5. 「値と演算」と「関数と定義域」のはなし　型は集合 Types as Sets</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="sect2 data-line-15">
<h3 id="_値と演算はペア">5.1. 値と演算はペア</h3>
<div class="paragraph data-line-17">
<p>結合性がある二項演算で</p>
</div>
<div class="paragraph data-line-19">
<p>\(1 + 2 + 3 = 6\)</p>
</div>
<div class="paragraph data-line-21">
<p>\(レゴブロックA + レゴブロックB + レゴブロックC = レゴブロックABC\)</p>
</div>
<div class="paragraph data-line-23">
<p>\(USB機器 + USB機器 + USB機器 = USB機器\)</p>
</div>
<div class="paragraph data-line-25">
<p>\(文字列 + 文字列 + 文字列 = 文字列\)</p>
</div>
<div class="paragraph data-line-27">
<p>と色々なモノイドが考えられるわけですが、ここで <code>+</code> と表現している二項の中置演算子ですが、同じ記号でも実際やってることはまるで違う！というのはわかります。</p>
</div>
<div class="paragraph data-line-29">
<p><code>+</code> という<strong>演算子は、値に紐付いたペアの片割れで値と切り離せません</strong>。</p>
</div>
<div class="imageblock data-line-31">
<div class="content">
<img src="./img/1-12-2020-08-40-10-AM.png" alt="1 12 2020 08 40 10 AM">
</div>
</div>
<div class="paragraph data-line-33">
<p>こういう二項演算で、値と演算子のペア、そして結合性があるし、ついでに単位元という存在もある、という縛りもふくめて、モノイドと呼びます。</p>
</div>
<div class="paragraph data-line-36">
<p>演算子の正体が突き詰めると、2つの引数をとる関数である、</p>
</div>
<div class="imageblock data-line-38">
<div class="content">
<img src="./img/1-12-2020-20-50-38-PM.png" alt="1 12 2020 20 50 38 PM">
</div>
</div>
<div class="paragraph data-line-40">
<p>ということを思い出すと、これはどういうことなのか？</p>
</div>
</div>
<div class="sect2 data-line-42">
<h3 id="_型とは集合のこと_types_as_sets">5.2. 型とは集合のこと Types as Sets</h3>
<div class="paragraph data-line-44">
<p>関数型プログラミングの根幹のパーツは関数ですが、それは集合論の写像と同じものである、というのは <em>🟧 <strong>UNIT 3 : 数学 Mathematics</strong>参照</em></p>
</div>
<div class="imageblock data-line-46">
<div class="content">
<img src="./img/2-7-2020-13-35-58-PM.png" alt="2 7 2020 13 35 58 PM">
</div>
</div>
<div class="paragraph data-line-48">
<p>集合 \(X\) の各要素 \(x\) に<br>
集合 \(Y\) の1つの要素 \(y\) を対応させる規則を<br>
\(X\)から\(Y\)への写像と呼びます。</p>
</div>
<table class="tableblock frame-all grid-all data-line-53" style="width: 80%;">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">オブジェクト指向</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">オブジェクト(object)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">メソッド(method)</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">代数学</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">値(value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">演算(operation)</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">解析学</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">定義域/始集合/終集合(domain/codomain)値域(range)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">関数(function)</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">集合論</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合(set) 始集合/終集合(domain/codomain)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">写像(map)</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">型理論</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">型(type)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">関数(function)/写像(map)</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">圏論</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">対象(object)/圏(category)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">射(morphism)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-62">
<p>この中で一番ゆるく、あんまり何にも考えておらずテキトーなせいで混乱しまくっている枠組みがオブジェクト指向なのですが、すでに「オブジェクト指向と二項演算の意外な関係性」として見たように、根源的には代数構造の二項演算と呼応しています。</p>
</div>
<div class="paragraph data-line-64">
<p>この中で、圏論(category theory)がもっとも根源的な枠組みとなります。<br>
数学はかつては集合論を基礎として構築されていましたが、現代では圏論を基礎として再構築されようとしています。</p>
</div>
<div class="paragraph data-line-67">
<p>先に集合論があり、その抽象度をさらにあげて一般化したものが圏論です。<br>
集合論は、圏論で記述することができて、それは、<a href="https://ja.wikipedia.org/wiki/%E9%9B%86%E5%90%88%E3%81%AE%E5%9C%8F">集合の圏</a>(category of sets)と言います。</p>
</div>
<div class="paragraph data-line-70">
<p>関数型プログラミングの範囲は、射(morphism)が写像・関数になっているという集合の圏=集合論です。</p>
</div>
<div class="paragraph data-line-72">
<p>この場合、定義域/始集合(domain) \(X\)とその要素である\(x\)について　<br>
<code>x</code> は <code>X</code> 型の値<br>
<code>x:X</code></p>
</div>
<div class="paragraph data-line-76">
<p>また、終集合(codomain) \(Y\)とその要素である\(y\)について　<br>
<code>y</code> は <code>Y</code> 型の値<br>
<code>y:Y</code></p>
</div>
<div class="paragraph data-line-80">
<p>と表現します。</p>
</div>
</div>
<div class="sect2 data-line-82">
<h3 id="_type_theory_versus_set_theory">5.3. Type theory versus set theory</h3>
<div class="paragraph data-line-84">
<p><a href="https://ncatlab.org/nlab/show/type+theory#type_theory_versus_set_theory" class="bare">https://ncatlab.org/nlab/show/type+theory#type_theory_versus_set_theory</a></p>
</div>
<div class="listingblock data-line-88">
<div class="content">
<pre>Alternately, we could change our terminology so that what we have been calling “types” are instead called “sets”.

あるいは、これまで「型」と呼んでいたものを「集合」と呼ぶように用語を変更することもできます。</pre>
</div>
</div>
<div class="listingblock data-line-96">
<div class="content">
<pre>Thus, words like “type” and “set” and “class” are really quite fungible. This sort of level-switch is especially important when we want to study the mathematics of type theory,

このように、「型」や「集合」や「クラス」などの言葉は、実はかなり代替可能です。このようなレベルの切り替えは、型理論の数学、つまり型理論の数学を研究するときには特に重要です。。</pre>
</div>
</div>
</div>
<div class="sect2 data-line-103">
<h3 id="_types_as_sets">5.4. Types as Sets</h3>
<div class="paragraph data-line-105">
<p><a href="https://guide.elm-lang.org/appendix/types_as_sets.html" class="bare">https://guide.elm-lang.org/appendix/types_as_sets.html</a></p>
</div>
<div class="paragraph data-line-107">
<p>これは、TypeScriptではなく、<a href="https://elm-lang.org/">Elm</a>言語のドキュメントなのですが、概念自体は全く同一で、解説されている内容はとても有用です。</p>
</div>
<div class="listingblock data-line-111">
<div class="content">
<pre>Elmプログラミングで最も重要なテクニックの一つは、コード内の値を実際に有効な値と正確に一致させることです。これでは無効なデータを残す余地がないので、私は常にカスタム型やデータ構造に注目することを推奨しています。

この目的を追求するにあたって、型（types）と集合(sets)の関係を理解しておくことが役立つことを私は発見しました。余計なことのように聞こえますが、それは貴方のマインドセットの形成に本当に役立つのです！

「型（types）を集合(sets)として」考えると、重要なクラスのバグ、つまり無効なデータを説明するのに役立ちます。

型をこのようなセットとして考えることは、言語が「簡単」、「制限的」、または「エラーが発生しやすい」と感じる理由を説明するのにも役立ちます。</pre>
</div>
</div>
<div class="paragraph data-line-122">
<p>本書の目的は関数型プログラミングの概念の解説であり、関数は集合論の写像のことであり、<strong>集合(Sets)こそがプログラミング世界で便利に利用されている型(Types)の正体である</strong>と理解することが役立つと紹介しました。</p>
</div>
<div class="paragraph data-line-124">
<p>関数とその定義域(始域)と終域、また写像と集合論はセットの概念で本来バラバラに扱うのはおかしいので、関数型プログラミングでも、集合の定義＝値の型付けが重要です。</p>
</div>
<div class="paragraph data-line-126">
<p>具体的な詳細は上記リンクから、英語が苦手な人はGoogle日本語翻訳が役立つでしょう。</p>
</div>
<div class="paragraph data-line-128">
<p>TypeScriptの型システムの詳細については本書の現段階では踏み込みません。</p>
</div>
</div>
<div class="sect2 data-line-131">
<h3 id="_巷によくあるよくわからない型の説明">5.5. 巷によくある、よくわからない「型」の説明</h3>
<div class="paragraph data-line-133">
<p>ほとんどのプログラマーは、多かれ少なかれ「どうやらプログラミングの世界には「型」というもののあるなしが非常に大きな問題として議論になっているようだ」というところから「型」の概念に遭遇することでしょう。</p>
</div>
<div class="paragraph data-line-135">
<p>JavaScriptは<a href="https://ja.wikipedia.org/wiki/%E5%8B%95%E7%9A%84%E5%9E%8B%E4%BB%98%E3%81%91">動的型付け</a>言語（dynamically typed language）です。</p>
</div>
<div class="listingblock data-line-140">
<div class="content">
<pre>プログラムにおいて、変数や、サブルーチンの引数や返り値などの値について、その型を、コンパイル時などそのプログラムの実行よりも前にあらかじめ決めるということをせず、実行時の実際の値による、という型システムの性質のことである。</pre>
</div>
</div>
<div class="imageblock data-line-145">
<div class="content">
<img src="./img/0-10-2020-08-06-33-AM.png" alt="0 10 2020 08 06 33 AM">
</div>
</div>
<div class="paragraph data-line-147">
<p><a href="https://www.typescriptlang.org/">TypeScript</a>は、<a href="https://ja.wikipedia.org/wiki/%E9%9D%99%E7%9A%84%E5%9E%8B%E4%BB%98%E3%81%91">静的型付け</a>言語（statically typed language）です。</p>
</div>
<div class="listingblock data-line-151">
<div class="content">
<pre>プログラムにおいて、変数や、サブルーチンの引数や返り値などの値について、その型が、コンパイル時など、そのプログラムの実行よりも前にあらかじめ決められている、という型システムの性質のことである。</pre>
</div>
</div>
<div class="paragraph data-line-155">
<p>現代のJavaScriptは強い型付けされた上位互換のTypeScriptとして、よりバグの混入のない関数型プログラミング言語として真価を発揮します。</p>
</div>
<div class="paragraph data-line-157">
<p>では、その素晴らしい「型」というものは何なのか？Wikipediaなどで調べてみると、</p>
</div>
<div class="paragraph data-line-159">
<p><a href="https://ja.wikipedia.org/wiki/%E5%9E%8B%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0">型システム</a></p>
</div>
<div class="listingblock data-line-163">
<div class="content">
<pre>型システム（英: type system）は、プログラミング言語において様々な法則から構成される論理体系であり、プログラム内の構成要素に型（type）と呼ばれるプログラム概念を付与する仕組みである。構成要素とは基本的な値（value）の他、変数、式、関数、オブジェクト、モジュールなどを指している。型の付与は主にデータの分類を成立させてデータ型を表現する他、データと暗黙情報を共に内包したデータ構造を形式化する。型システムの意義は、プログラム要素を分類し、各分類の識別法則の一貫性および各分類間の関連法則の整合性を保証して、プログラムエラーの発生を抑止することにある。型システムは、数理論理学の型理論に基づいて構築されたプログラミング用の形式手法である。</pre>
</div>
</div>
<div class="paragraph data-line-167">
<p>初学者というか多くの、ほとんどのプログラマーが「型」とは何か？と概念を習得したいときに、この説明でわかるとは到底思えません。</p>
</div>
<div class="paragraph data-line-169">
<p>巷にあふれる「型の説明」とは、おぼろげに見えるような景色をスケッチしているようなもので、実際はなんの説明にもなっていないことがほとんどです。説明している人たちが自分が何を言っているのかよくわかっていないからです。</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4">
<h2 id="_関数のための演算子">6. 関数のための演算子</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="sect2 data-line-15">
<h3 id="_パイプライン演算子pipeline_operator">6.1. パイプライン演算子(Pipeline operator)</h3>
<div class="imageblock data-line-17">
<div class="content">
<img src="./img/1-12-2020-08-25-10-AM.png" alt="1 12 2020 08 25 10 AM">
</div>
</div>
<div class="paragraph data-line-19">
<p>で、ある値とある関数を接続する二項演算の演算子としてもっとも単純なものは、</p>
</div>
<div class="paragraph data-line-22">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Pipeline_operator">パイプライン演算子(Pipeline operator) (|&gt;)</a>です。</p>
</div>
<div class="literalblock data-line-24">
<div class="content">
<pre>関数呼び出しの連結実験的なパイプライン演算子 |&gt; (現在はステージ 1 です) は、式の値を関数に接続します。これによって、読みやすい方法で一連の関数呼び出しを作成することができます。結果的に、単一の引数を用いた関数呼び出しの糖衣構文となり、次のように書くことができます。</pre>
</div>
</div>
<div class="imageblock data-line-26">
<div class="content">
<img src="./img/6-7-2020-21-36-55-PM.png" alt="6 7 2020 21 36 55 PM">
</div>
</div>
<div class="paragraph data-line-28">
<p>これは、従来からの関数適用の表記</p>
</div>
<div class="imageblock data-line-30">
<div class="content">
<img src="./img/6-7-2020-21-26-22-PM.png" alt="6 7 2020 21 26 22 PM">
</div>
</div>
<div class="paragraph data-line-32">
<p>の置き換えですが、集合と関数として眺めた場合、</p>
</div>
<div class="imageblock data-line-34">
<div class="content">
<img src="./img/2-7-2020-13-48-34-PM.png" alt="2 7 2020 13 48 34 PM">
</div>
</div>
<div class="paragraph data-line-36">
<p>パイプライン演算子のほうがむしろ直感的な記法であることがわかります。</p>
</div>
<table class="tableblock frame-all grid-all data-line-40" style="width: 80%;">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">インプット</th>
<th class="tableblock halign-center valign-top">アウトプット</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">xy</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(y\)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">f(x)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(f(x)\)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">パイプライン</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>x |&gt; f</code></p></td>
</tr>
</tbody>
</table>
<div class="listingblock data-line-58">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">   const f = a =&gt; console.log(a);

    f("hello"); //hello

    "hello" |&gt; f; //hello</code></pre>
</div>
</div>
<div class="paragraph data-line-68">
<p>JavaScriptでは<a href="https://github.com/tc39/proposal-pipeline-operator">実験的に導入がはじまろうとしている段階</a>です。</p>
</div>
<div class="imageblock data-line-70">
<div class="content">
<img src="./img/1-12-2020-10-52-48-AM.png" alt="1 12 2020 10 52 48 AM">
</div>
</div>
<div class="listingblock data-line-75">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">const double = n =&gt; n * 2;
const increment = n =&gt; n + 1;

// パイプライン演算子なし
double(increment(double(double(5)))); // 42

// パイプライン演算子あり
5 |&gt; double |&gt; double |&gt; increment |&gt; double; // 42</code></pre>
</div>
</div>
<div class="imageblock data-line-86">
<div class="content">
<img src="./img/1-12-2020-10-21-34-AM.png" alt="1 12 2020 10 21 34 AM">
</div>
</div>
<div class="imageblock data-line-89">
<div class="content">
<img src="./img/5-7-2020-21-16-07-PM.png" alt="5 7 2020 21 16 07 PM">
</div>
</div>
<div class="paragraph data-line-92">
<p>パイプライン演算子(PipelineOperator)は、TypeScirpt4.0以降では実験的に導入され使用可能なので、本書ではパイプライン演算子を積極的に活用していきます。</p>
</div>
<div class="paragraph data-line-94">
<p><a href="https://github.com/microsoft/TypeScript/pull/38305">microsoft/TypeScript Add support for Pipeline Operator</a></p>
</div>
<div class="paragraph data-line-96">
<p><a href="https://www.typescriptlang.org/play?ts=4.0.0-pr-38305-12#code/EQCwpgNhD2AEAOBLelEDsy2igTgQwBdocBCYWAHwD5YBjaNAZ2gjADoYBzAbgChf6TArAAm0AK4AjVrAC8sNHJqKAVLABMfQY2HpaOMAFswaYfMWzlsANSwAjHwENmrDtE4AKXrB9iprDz0DY1MPP2kwMIkIjwBWAEpE+N54x1jKGnCZalFo7JogoxNhHKywbwy6ZxZ2Lm4fIA">TypeScript Playground</a></p>
</div>
<div class="imageblock data-line-98">
<div class="content">
<img src="./img/1-12-2020-10-31-28-AM.png" alt="1 12 2020 10 31 28 AM">
</div>
</div>
</div>
<div class="sect2 data-line-100">
<h3 id="_合成関数写像の合成">6.2. 合成関数（写像の合成）</h3>
<div class="imageblock data-line-102">
<div class="content">
<img src="./img/1-8-2020-08-30-56-AM.png" alt="1 8 2020 08 30 56 AM">
</div>
</div>
<div class="paragraph data-line-104">
<p>今、入力装置（カメラなど）からサイコロの目のイメージのデータがインプットされ、<br>
画像認識して数値に変換できる機械学習済のコンピュータビジョンの関数が用意されており、<br>
さらに、簡単な関数で数値を偶数か奇数かに変換できる関数があるとします。</p>
</div>
<div class="imageblock data-line-108">
<div class="content">
<img src="./img/5-7-2020-23-29-42-PM.png" alt="5 7 2020 23 29 42 PM">
</div>
</div>
<div class="paragraph data-line-110">
<p>これは、サイコロの目のイメージのデータから<br>
それが偶数なのか奇数なのか判定できる<br>
<a href="https://ja.wikipedia.org/wiki/%E4%B8%81%E5%8D%8A">丁半博打</a>で需要がありそうな、ひとつのシステム＝プログラムです。</p>
</div>
<div class="paragraph data-line-114">
<p>関数型プログラミングのコードは数式なのですが、根本的には、こういう関数の合成（関数の接続）をしていく作業です。</p>
</div>
<div class="paragraph data-line-116">
<p><strong>\(f\): 画像認識して数値に変換できる機械学習済のコンピュータビジョンの関数</strong><br>
<strong>\(g\) : 数値を偶数か奇数かに変換できる関数</strong></p>
</div>
<div class="paragraph data-line-119">
<p>\(f\) と \(g\) を合成します。</p>
</div>
<div class="imageblock data-line-121">
<div class="content">
<img src="./img/1-10-2020-09-40-23-AM.png" alt="1 10 2020 09 40 23 AM">
</div>
</div>
<div class="imageblock data-line-123">
<div class="content">
<img src="./img/1-12-2020-11-20-10-AM.png" alt="1 12 2020 11 20 10 AM">
</div>
</div>
<div class="paragraph data-line-125">
<p><strong>\(f ・ g\) : 画像認識して数値を偶数か奇数かに変換できる関数</strong></p>
</div>
</div>
<div class="sect2 data-line-127">
<h3 id="_写像関数の合成はmonoidモノイド">6.3. 写像/関数の合成はMonoid(モノイド)</h3>
<div class="paragraph data-line-129">
<p>さらにもっと複雑なプログラムのコードの場合、</p>
</div>
<div class="paragraph data-line-131">
<p>\(f\) と \(g\) と \(h\) を合成します。</p>
</div>
<div class="paragraph data-line-133">
<p><span class="image"><img src="./img/1-10-2020-09-51-24-AM.png" alt="1 10 2020 09 51 24 AM"></span></p>
</div>
<div class="imageblock data-line-135">
<div class="content">
<img src="./img/1-12-2020-11-32-43-AM.png" alt="1 12 2020 11 32 43 AM">
</div>
</div>
<div class="paragraph data-line-138">
<p><span class="image"><img src="./img/1-7-2020-09-05-29-AM.png" alt="1 7 2020 09 05 29 AM"></span></p>
</div>
<div class="imageblock data-line-141">
<div class="content">
<img src="./img/1-12-2020-08-54-11-AM.png" alt="1 12 2020 08 54 11 AM">
</div>
</div>
<div class="paragraph data-line-143">
<p>というパターンで結合性があるので写像/関数の合成はモノイドです。</p>
</div>
<div class="paragraph data-line-145">
<p>そして、</p>
</div>
<div class="imageblock data-line-147">
<div class="content">
<img src="./img/1-12-2020-11-56-15-AM.png" alt="1 12 2020 11 56 15 AM">
</div>
</div>
<div class="paragraph data-line-149">
<p>なので、関数合成という二項演算で、結合性があるモノイド</p>
</div>
<div class="imageblock data-line-151">
<div class="content">
<img src="./img/1-12-2020-11-55-18-AM.png" alt="1 12 2020 11 55 18 AM">
</div>
</div>
</div>
<div class="sect2 data-line-153">
<h3 id="_関数合成演算子">6.4. 関数合成演算子</h3>
<div class="imageblock data-line-155">
<div class="content">
<img src="./img/1-12-2020-11-57-57-AM.png" alt="1 12 2020 11 57 57 AM">
</div>
</div>
<div class="paragraph data-line-157">
<p>関数　<code>.</code> 関数　＝　合成関数</p>
</div>
<div class="paragraph data-line-159">
<p>というイメージの中置の二項演算子を定義することを試みます。</p>
</div>
<div class="paragraph data-line-161">
<p>まず、2つの関数 <code>f</code> と <code>g</code> をインプットとし、<br>
合成された関数をアウトプットする関数 <code>composition</code>　を定義します。</p>
</div>
<div class="listingblock data-line-165">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  const composition =
    g =&gt; f =&gt; x =&gt; x |&gt; f |&gt; g;</code></pre>
</div>
</div>
<div class="paragraph data-line-170">
<p>すでに用意した <code>customOperator</code> 関数</p>
</div>
<div class="listingblock data-line-174">
<div class="title">JavaScript演算子のユーザ定義のための関数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  const customOperator = op =&gt; f =&gt; set =&gt;
      Object.defineProperty(set, op, {
        value: function (a) {
          return f(a)(this);
        }
      });//returns new set/object</code></pre>
</div>
</div>
<div class="paragraph data-line-184">
<p>を利用して<br>
<code>composition</code> を <code>.</code> で表現するように定義します。</p>
</div>
<div class="listingblock data-line-188">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  Function.prototype |&gt;
    customOperator(`.`)
      (composition);</code></pre>
</div>
</div>
<div class="paragraph data-line-194">
<p>具体的な関数 <code>f</code> <code>g</code> <code>h</code> を用意する。</p>
</div>
<div class="listingblock data-line-197">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  const f = x =&gt; x * 2;
  const g = x =&gt; x + 1;
  const h = x =&gt; x ** 3;</code></pre>
</div>
</div>
<div class="paragraph data-line-203">
<p><code>f</code> と <code>g</code> を合成します。</p>
</div>
<div class="imageblock data-line-205">
<div class="content">
<img src="./img/1-10-2020-09-40-23-AM.png" alt="1 10 2020 09 40 23 AM">
</div>
</div>
<div class="listingblock data-line-208">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  {
    1 |&gt; f |&gt; g
      |&gt; console.log; //3
  }
  {//function composition
    const fg = composition(g)(f);
    fg(1)
      |&gt; console.log; //3
  }
  {//function composition
    const fg = (f)[`.`](g);
    fg(1)
      |&gt; console.log; //3
  }</code></pre>
</div>
</div>
<div class="listingblock data-line-227">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">3
3
3</code></pre>
</div>
</div>
<div class="paragraph data-line-234">
<p><code>f</code> と <code>g</code> と <code>h</code> を合成します。</p>
</div>
<div class="imageblock data-line-236">
<div class="content">
<img src="./img/1-10-2020-09-51-24-AM.png" alt="1 10 2020 09 51 24 AM">
</div>
</div>
<div class="listingblock data-line-239">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  {
    1 |&gt; f |&gt; g |&gt; h
      |&gt; console.log; //27
  }
  {//function composition is nested
    const fgh = composition(h)(composition(g)(f));
    fgh(1)
      |&gt; console.log; //27
  }
  {//function composition
    const fgh = (f)[`.`](g)[`.`](h);
    fgh(1)
      |&gt; console.log; //27
  }</code></pre>
</div>
</div>
<div class="listingblock data-line-259">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">27
27
27</code></pre>
</div>
</div>
<div class="paragraph data-line-265">
<p>前置記法の <code>f(x)</code> この場合は</p>
</div>
<div class="listingblock data-line-269">
<div class="title">ネストされてしまう前置記法のcomposition関数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">composition(h)(composition(g)(f))</code></pre>
</div>
</div>
<div class="paragraph data-line-273">
<p>とネストしてしまいますが、<br>
中置記法の　<code>|&gt;</code> パイプラインオペレータや、関数合成のカスタム二項演算子 <code>.</code> では、</p>
</div>
<div class="listingblock data-line-278">
<div class="title">関数適用と関数合成の中置記法</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs"> 1 |&gt; f |&gt; g |&gt; h

(f)[`.`](g)[`.`](h)</code></pre>
</div>
</div>
<div class="paragraph data-line-284">
<p>と、関数合成のイメージどおりに記述できます。</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4">
<h2 id="_functorendofunctor">7. Functor(endoFunctor)</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="sect2 data-line-15">
<h3 id="_関数合成">7.1. 関数合成</h3>
<div class="paragraph data-line-17">
<p><code>f</code> と <code>g</code> と <code>h</code> を合成します。</p>
</div>
<div class="imageblock data-line-19">
<div class="content">
<img src="./img/1-10-2020-09-51-24-AM.png" alt="1 10 2020 09 51 24 AM">
</div>
</div>
<div class="imageblock data-line-22">
<div class="content">
<img src="./img/1-12-2020-11-55-18-AM.png" alt="1 12 2020 11 55 18 AM">
</div>
</div>
<div class="listingblock data-line-26">
<div class="title">関数合成の中置記法の二項演算</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">const fgh = (f)[`.`](g)[`.`](h);</code></pre>
</div>
</div>
<div class="paragraph data-line-30">
<p>今、例えば、</p>
</div>
<div class="listingblock data-line-33">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">1 |&gt; f |&gt; g |&gt; h</code></pre>
</div>
</div>
<div class="paragraph data-line-37">
<p>という、関数適用があるとして、<br>
これは、<code>1</code> を、合成した関数 <code>fgh</code> にインプットすることと同じです。</p>
</div>
<div class="listingblock data-line-41">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">1 |&gt; fgh</code></pre>
</div>
</div>
<div class="paragraph data-line-45">
<p>合成関数 <code>fgh</code> を再び二項演算に開くとこうなります。</p>
</div>
<div class="listingblock data-line-48">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">1 |&gt; ((f)[`.`](g)[`.`](h))</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-52">
<h3 id="_array_map">7.2. Array.map()</h3>
<div class="paragraph data-line-54">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map" class="bare">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></p>
</div>
<div class="paragraph data-line-56">
<p>Array.map()は、「オブジェクト指向と二項演算の意外な関係性」で確認したとおり二項演算です。</p>
</div>
<div class="paragraph data-line-58">
<p><code>[1, 2].map(f)</code></p>
</div>
<div class="paragraph data-line-60">
<p>とあった場合、これは</p>
</div>
<div class="paragraph data-line-62">
<p><code>map</code> という中置演算子をもって</p>
</div>
<div class="paragraph data-line-64">
<p><code>[1, 2]</code> <code>map</code> <code>f</code></p>
</div>
<div class="paragraph data-line-66">
<p>と、配列と関数を接続して演算していることになります。</p>
</div>
<div class="listingblock data-line-69">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const f = x =&gt; x * 2;
    const g = x =&gt; x + 1;
    const h = x =&gt; x ** 3;</code></pre>
</div>
</div>
<div class="paragraph data-line-75">
<p>と適当な関数を３つ定義しておきましょう。</p>
</div>
<div class="paragraph data-line-77">
<p>普通に、<code>Arra.map()</code> というオブジェクトとメソッドの記法ではこうなります。<br>
メソッドチェーンなどと呼ばれているやつですね。</p>
</div>
<div class="listingblock data-line-81">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    [1, 2].map(f).map(g).map(h)  // [ 27, 125 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-85">
<p><code>map</code> というメソッド、あるいは二項演算子は特に性質がよく設計されていて、</p>
</div>
<div class="listingblock data-line-88">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    1 |&gt; fgh
    1 |&gt; ((f)[`.`](g)[`.`](h))</code></pre>
</div>
</div>
<div class="paragraph data-line-93">
<p>と同じ原理で、</p>
</div>
<div class="listingblock data-line-96">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    [1, 2].map((f)[`.`](g)[`.`](h))  // [ 27, 125 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-100">
<p><code>fgh</code> を関数合成してから <code>map</code> しても同じ値になります。</p>
</div>
<div class="paragraph data-line-102">
<p>つまり、<code>f</code> <code>g</code> <code>h</code> が関数合成できた、という結合性が <code>map</code> 演算子のエコでも成立しているということです。</p>
</div>
<div class="paragraph data-line-104">
<p>オブジェクトのメソッドはそのまま、ユーザ定義演算子のようにも書けます。</p>
</div>
<div class="listingblock data-line-107">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    [1, 2][`map`](f)[`map`](g)[`map`](h)  // [ 27, 125 ]
    [1, 2][`map`]((f)[`.`](g)[`.`](h))  // [ 27, 125 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-112">
<p>ここで <code>.map</code> メソッドを独立した関数として切り出してみましょう。</p>
</div>
<div class="paragraph data-line-114">
<p><code>.map</code> メソッドのオブジェクト・クラスは配列で、配列を出力するので、<br>
<code>map</code> 関数 の定義域は配列、値域も配列と自動的になります。</p>
</div>
<div class="listingblock data-line-118">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const map =
      f =&gt;
        array =&gt; array.map(f);

    map(f)([1, 2]) // [ 2, 4 ]
    [1, 2] |&gt; map(f) // [ 2, 4 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-127">
<p><code>map</code> 関数をユーザ定義の演算子に変換します。</p>
</div>
<div class="listingblock data-line-130">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    Array.prototype |&gt;
      customOperator(`&gt;&gt;`)
        (map);

    [1, 2][`&gt;&gt;`](f)[`&gt;&gt;`](g)[`&gt;&gt;`](h) // [ 27, 125 ]
    [1, 2][`&gt;&gt;`]((f)[`.`](g)[`.`](h))  // [ 27, 125 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-139">
<p><code>Array.map</code> オブジェクトとメソッド から<br>
 <code>map</code> 関数を切り出して、<code>&gt;&gt;</code> という中置演算子に変換して、いってこいで</p>
</div>
<div class="paragraph data-line-142">
<p><code>.map</code> メソッドの文字列であった式が</p>
</div>
<div class="listingblock data-line-145">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    [1, 2][`map`](f)[`map`](g)[`map`](h)  // [ 27, 125 ]
    [1, 2][`map`]((f)[`.`](g)[`.`](h))  // [ 27, 125 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-150">
<p>と 演算子記号 <code>&gt;&gt;</code> にそのまま入れ替わっています。</p>
</div>
<div class="paragraph data-line-152">
<p>また、</p>
</div>
<div class="listingblock data-line-155">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    map(f)([1, 2]) // [ 2, 4 ]
    [1, 2] |&gt; map(f) // [ 2, 4 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-160">
<p>であるので、<br>
<code>map</code> 関数をパイプライン演算子と組み合わせてそのまま、使うこともできます。</p>
</div>
<div class="listingblock data-line-164">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    [1, 2]
      |&gt; map(f) |&gt; map(g) |&gt; map(h)  // [ 27, 125 ]
    [1, 2]
      |&gt; map((f)[`.`](g)[`.`](h))  // [ 27, 125 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-171">
<p>また、</p>
</div>
<div class="listingblock data-line-174">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    [1, 2]
      |&gt; map(f) |&gt; map(g) |&gt; map(h)  // [ 27, 125 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-179">
<p>ということは、</p>
</div>
<div class="imageblock data-line-181">
<div class="content">
<img src="./img/2-12-2020-05-13-37-AM.png" alt="2 12 2020 05 13 37 AM">
</div>
</div>
<div class="listingblock data-line-184">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    [1, 2]
      |&gt; ((map(f))[`.`](map(g))[`.`](map(h)))  // [ 27, 125 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-189">
<p>というように関数合成もできます。</p>
</div>
<div class="paragraph data-line-191">
<p>このように、</p>
</div>
<div class="imageblock data-line-193">
<div class="content">
<img src="./img/1-12-2020-08-25-10-AM.png" alt="1 12 2020 08 25 10 AM">
</div>
</div>
<div class="paragraph data-line-195">
<p>で結合性がある二項演算のことを<strong>(endo)Functor</strong>と呼びます。</p>
</div>
<div class="paragraph data-line-197">
<p>Functorは圏論(category theory)から発展してきた概念なのですが、<br>
関数型プログラミングの範囲、<br>
それは集合の圏(category of sets)という範囲(圏)なのですが、<br>
もっと言い換えて、特に本書で徹底的に解説している<br>
代数構造の二項演算では実はかなりシンプルです。</p>
</div>
<div class="paragraph data-line-203">
<p>上にダーッと書いたように、結合性があり、いじくり倒しても組み合わせは爆発して異なる値にはならない、全部同じ値になると保証されている、プログラムは複雑性から解放される、ということが最終的な目標です。</p>
</div>
<div class="paragraph data-line-205">
<p>あくまでほしいのは結合性。</p>
</div>
<div class="paragraph data-line-207">
<p>そして非常に美しくラッキーな事実があります。</p>
</div>
</div>
<div class="sect2 data-line-209">
<h3 id="_identity_と_functorという二項演算">7.3. identity と Functorという二項演算</h3>
<div class="listingblock data-line-212">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const identity = a =&gt; a;</code></pre>
</div>
</div>
<div class="paragraph data-line-216">
<p>こういうインプットとアウトプットが常に同じ、という関数は、<code>identity</code> と呼ばれています。<br>
自分自身をそのまま返す関数、不変の結果をもたらす関数です。</p>
</div>
<div class="paragraph data-line-219">
<p>たとえば、</p>
</div>
<div class="listingblock data-line-222">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    (5 |&gt; identity) === 5 //true</code></pre>
</div>
</div>
<div class="paragraph data-line-226">
<p>です。</p>
</div>
<div class="paragraph data-line-228">
<p>ここで、</p>
</div>
<div class="imageblock data-line-231">
<div class="content">
<img src="./img/1-12-2020-08-25-10-AM.png" alt="1 12 2020 08 25 10 AM">
</div>
</div>
<div class="paragraph data-line-233">
<p>のうち、</p>
</div>
<div class="paragraph data-line-235">
<p>その演算の右辺の関数が、<code>identity</code> であるとき、</p>
</div>
<div class="imageblock data-line-237">
<div class="content">
<img src="./img/2-12-2020-05-42-57-AM.png" alt="2 12 2020 05 42 57 AM">
</div>
</div>
<div class="listingblock data-line-240">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    (5 |&gt; identity) === 5 //true</code></pre>
</div>
</div>
<div class="paragraph data-line-244">
<p><code>a</code> の値が変化しない二項演算ならは、もれなくすべて、上で羅列したような結合性が自動的に備わっていることが知られています。</p>
</div>
<div class="paragraph data-line-246">
<p><a href="https://stackoverflow.com/questions/8305949/haskell-functor-implied-law" class="bare">https://stackoverflow.com/questions/8305949/haskell-functor-implied-law</a></p>
</div>
<div class="paragraph data-line-248">
<p><a href="https://github.com/quchen/articles/blob/master/second_functor_law.md">The second Functor law is redundant</a></p>
</div>
<div class="paragraph data-line-250">
<p>この二項演算を(endo)Functorと言います。</p>
</div>
</div>
<div class="sect2 data-line-252">
<h3 id="_もっともシンプルなfunctoridentityfunctor_それはパイプラインという二項演算">7.4. もっともシンプルなFunctor=identityFunctor それはパイプラインという二項演算</h3>
<div class="imageblock data-line-254">
<div class="content">
<img src="./img/2-12-2020-05-42-57-AM.png" alt="2 12 2020 05 42 57 AM">
</div>
</div>
<div class="paragraph data-line-256">
<p>ならば(endo)Functorです。</p>
</div>
<div class="listingblock data-line-259">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    (5 |&gt; identity) === 5 //true</code></pre>
</div>
</div>
<div class="paragraph data-line-263">
<p>これ、パイプライン演算子の二項演算は該当しますよね？</p>
</div>
<div class="imageblock data-line-265">
<div class="content">
<img src="./img/2-12-2020-06-25-54-AM.png" alt="2 12 2020 06 25 54 AM">
</div>
</div>
<div class="paragraph data-line-267">
<p>つまり、パイプライン演算はもっともシンプルなFunctorです。</p>
</div>
<div class="paragraph data-line-269">
<p>もうちょっと複雑だが慣れ親しんでいる(endo)Functorは <code>Array.map</code> でしょう。</p>
</div>
<div class="listingblock data-line-272">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    [1, 2].map(identity)   // [ 1, 2 ]
    [1, 2][`map`](identity)  // [ 1, 2 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-277">
<p>です。Functorとしての条件を満たすので、自動的に結合性も備え、爆発する複雑性がない堅牢な代数構造であることが保証されています。</p>
</div>
<div class="paragraph data-line-279">
<p>これは、</p>
</div>
<div class="listingblock data-line-282">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    map(identity)([1, 2]) // [ 1, 2 ]
    [1, 2] |&gt; map(identity) // [ 1, 2 ]</code></pre>
</div>
</div>
<div class="paragraph data-line-287">
<p>と書けましたが、</p>
</div>
<div class="paragraph data-line-289">
<p><code>map</code> 関数を<br>
<code>identity</code> 関数に置き換えると、</p>
</div>
<div class="listingblock data-line-293">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    (identity)(identity)(5) // 5
    5 |&gt; identity(identity) // 5</code></pre>
</div>
</div>
<div class="paragraph data-line-298">
<p>こうなります。</p>
</div>
<div class="paragraph data-line-300">
<p><code>identity(identity)</code> の値は簡約されて <code>identity</code> となるので。</p>
</div>
<div class="listingblock data-line-303">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    (identity)(5) // 5
    5 |&gt; identity // 5</code></pre>
</div>
</div>
<div class="paragraph data-line-308">
<p><code>map</code> の部分が <code>identity</code> の場合素通りし、</p>
</div>
<div class="paragraph data-line-310">
<p>ただの普通のパイプライン演算、つまり普通の</p>
</div>
<div class="imageblock data-line-312">
<div class="content">
<img src="./img/6-7-2020-21-26-22-PM.png" alt="6 7 2020 21 26 22 PM">
</div>
</div>
<div class="paragraph data-line-313">
<p><code>f(x)</code> になってしまいます。</p>
</div>
<div class="paragraph data-line-315">
<p><code>map</code> の部分が <code>identity</code> になっているので、identity Functor と呼ばれています。</p>
</div>
</div>
<div class="sect2 data-line-317">
<h3 id="_関数の合成もendofunctor">7.5. 関数の合成も(endo)Functor</h3>
<div class="imageblock data-line-319">
<div class="content">
<img src="./img/2-12-2020-06-13-26-AM.png" alt="2 12 2020 06 13 26 AM">
</div>
</div>
<div class="paragraph data-line-321">
<p>このパターンで、</p>
</div>
<div class="paragraph data-line-323">
<p>\(g\) == <code>identity</code> ならば、<br>
値は、\(g\) を素通りしているので、結果<br>
合成関数
\(f.g\) == \(f\)<br>
となります。</p>
</div>
<div class="paragraph data-line-329">
<p>つまり、</p>
</div>
<div class="imageblock data-line-331">
<div class="content">
<img src="./img/2-12-2020-07-01-08-AM.png" alt="2 12 2020 07 01 08 AM">
</div>
</div>
<div class="paragraph data-line-334">
<p>関数の合成も(endo)Functorです。</p>
</div>
<div class="paragraph data-line-336">
<p>このように、普通の関数適用</p>
</div>
<div class="imageblock data-line-338">
<div class="content">
<img src="./img/6-7-2020-21-26-22-PM.png" alt="6 7 2020 21 26 22 PM">
</div>
</div>
<div class="paragraph data-line-340">
<p>あるいは別記法であるパイプライン演算子の二項演算</p>
</div>
<div class="imageblock data-line-342">
<div class="content">
<img src="./img/6-7-2020-21-36-55-PM.png" alt="6 7 2020 21 36 55 PM">
</div>
</div>
<div class="paragraph data-line-344">
<p>それから</p>
</div>
<div class="imageblock data-line-346">
<div class="content">
<img src="./img/2-12-2020-06-13-26-AM.png" alt="2 12 2020 06 13 26 AM">
</div>
</div>
<div class="paragraph data-line-348">
<p>をもっとも基本的なものとし、それらを包括した<br>
ここでは特に二項演算として取り扱っていますが、<br>
(endo)Funcorと呼ばれるシンプルな代数構造に集約されてしまいました。</p>
</div>
<div class="paragraph data-line-352">
<p>(endo)Functorとは、</p>
</div>
<div class="imageblock data-line-354">
<div class="content">
<img src="./img/1-12-2020-08-25-10-AM.png" alt="1 12 2020 08 25 10 AM">
</div>
</div>
<div class="paragraph data-line-356">
<p>かつ</p>
</div>
<div class="imageblock data-line-358">
<div class="content">
<img src="./img/2-12-2020-07-06-05-AM.png" alt="2 12 2020 07 06 05 AM">
</div>
</div>
<div class="paragraph data-line-360">
<p>である二項演算。</p>
</div>
<div class="paragraph data-line-362">
<p>あるいは、</p>
</div>
<div class="imageblock data-line-364">
<div class="content">
<img src="./img/2-12-2020-06-56-46-AM.png" alt="2 12 2020 06 56 46 AM">
</div>
</div>
<div class="paragraph data-line-366">
<p>かつ</p>
</div>
<div class="imageblock data-line-368">
<div class="content">
<img src="./img/2-12-2020-07-08-41-AM.png" alt="2 12 2020 07 08 41 AM">
</div>
</div>
<div class="paragraph data-line-370">
<p>である二項演算です。</p>
</div>
<div class="paragraph data-line-372">
<p>そして、(endo)Functorであるならば、</p>
</div>
<div class="imageblock data-line-374">
<div class="content">
<img src="./img/2-12-2020-07-34-58-AM.png" alt="2 12 2020 07 34 58 AM">
</div>
</div>
<div class="paragraph data-line-376">
<p>など結合性により、計算順序が異なったとしても結果が同一になります。</p>
</div>
</div>
<div class="sect2 data-line-378">
<h3 id="_関数の合成はmonadモナド">7.6. 関数の合成はMonad(モナド)</h3>
<div class="paragraph data-line-380">
<p>関数の合成も(endo)Functorであるのは確認しましたが、よくよく思い出してみると、</p>
</div>
<div class="imageblock data-line-382">
<div class="content">
<img src="./img/2-12-2020-06-47-41-AM.png" alt="2 12 2020 06 47 41 AM">
</div>
</div>
<div class="imageblock data-line-384">
<div class="content">
<img src="./img/2-12-2020-06-39-53-AM.png" alt="2 12 2020 06 39 53 AM">
</div>
</div>
<div class="paragraph data-line-386">
<p>という件もありました。</p>
</div>
<div class="paragraph data-line-388">
<p>つまり、</p>
</div>
<div class="paragraph data-line-390">
<p>関数の合成は</p>
</div>
<div class="ulist data-line-392">
<ul>
<li class="data-line-392">
<p><strong>Monoid(モノイド)</strong></p>
</li>
<li class="data-line-393">
<p><strong>endoFunctor</strong></p>
</li>
</ul>
</div>
<div class="paragraph data-line-395">
<p>という双方、結合性にまつわる２つの代数構造がもつ性質を同時に備えています。</p>
</div>
<div class="paragraph data-line-397">
<p>この特殊な代数構造、これも当然、二項演算ですが、<br>
<strong>Monad(モナド)</strong>と呼ばれています。</p>
</div>
<div class="paragraph data-line-400">
<p>そして繰り返しとなりますが、UNIT 1は、一番大枠の俯瞰図を示すことを最優先としているため、関数、高階関数、カリー化、それからMonadなどの詳細については、<em>🟧 <strong>UNIT 3 : 数学 Mathematics</strong>参照</em> とします。</p>
</div>
</div>
</div>
</div>
<h1 id="_unit_2_フローから依存グラフの式へ" class="sect0 data-line-96">🟧 UNIT 2 : フローから依存グラフの式へ</h1>
<div class="sect1 data-line-4">
<h2 id="_条件分岐">1. 条件分岐</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="admonitionblock caution data-line-16">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph data-line-17">
<p>完成から程遠い　10％以下　のドキュメント</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-20">
<p>入力（パターンマッチ）＝結果</p>
</div>
<div class="paragraph data-line-22">
<p>in 演算子</p>
</div>
<div class="paragraph data-line-24">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/in" class="bare">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/in</a></p>
</div>
<div class="paragraph data-line-26">
<p>三項演算子</p>
</div>
<div class="paragraph data-line-100">
<p>Option Type</p>
</div>
</div>
</div>
<div class="sect1 data-line-4">
<h2 id="_依存グラフ">2. 依存グラフ</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="admonitionblock caution data-line-16">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph data-line-17">
<p>完成から程遠い　10％以下　のドキュメント</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-21">
<p>一般に反復で「式」を使う正しいやりかたとは、</p>
</div>
<div class="paragraph data-line-23">
<p>モノイド(Monoid)という代数構造 の畳み込み関数(Fold/reduce)を利用する。例↓</p>
</div>
<div class="imageblock data-line-25">
<div class="content">
<img src="./img/2-12-2020-17-16-11-PM.png" alt="2 12 2020 17 16 11 PM">
</div>
</div>
<div class="paragraph data-line-28">
<p>まず1–5の数列(Array)を素直に用意しておき（データを作りながら計算などしない、データは最初から全部用意する）、それを畳み込む(Array.reduce)だけです。</p>
</div>
<div class="literalblock data-line-30">
<div class="content">
<pre>const sequence =
      [...Array(5).keys()] // [0,1,..,4]
         .map(a =&gt; a + 1); // [1,2,..,5]</pre>
</div>
</div>
<div class="paragraph data-line-34">
<p>const multiply = (a, b) &#8658; a * b;
const result = sequence.reduce(multiply);</p>
</div>
<div class="paragraph data-line-37">
<p>console.log(result); //120
このコードは、どこにもfor文という制御構文も、それに含まれている条件分岐もありません。シンプルで間違いがありません。</p>
</div>
<div class="paragraph data-line-40">
<p>このように、順次はちょっとさらにややこしいので今回は省略で、デフォのJavaScriptの上から下へをそのまま踏襲しますけども、分岐、反復については、if構文、for構文という制御構文を使うことなしに、式の計算だけでやる、というスマートな方法、つまり複雑なフローチャートでやる命令型プログラミングではなく、値と式、関数だけ使う宣言型、関数型プログラミングを紹介しました。</p>
</div>
<div class="sect2 data-line-44">
<h3 id="_フローがなくイミュータブルな式のコード関数型プログラミング">2.1. フローがなくイミュータブルな式のコード＝関数型プログラミング</h3>
<div class="listingblock data-line-48">
<div class="title">Functional</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">   const natural = n =&gt;
      [...Array(n).keys()]
        .map(a =&gt; a + 1);

    console.log(natural(10));
    //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    const plus = (a, b) =&gt; a + b;

    const result = natural(10).reduce(plus);

    console.log(result);//55</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4">
<h2 id="_世界モデル">3. 世界モデル</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="sect2 data-line-16">
<h3 id="_関数型プログラミングの実用化に立ち塞がる最大のメンタルブロック">3.1. 関数型プログラミングの実用化に立ち塞がる最大のメンタルブロック</h3>
<div class="paragraph data-line-18">
<p>実際この問題は、関数型プログラミング、そしてプログラミング全般において、かなり重要でありながらも、根本的な要点では、きちんと語られないトピックであり、自分がことあるごとに語ろうとしているトピックでもあります。</p>
</div>
<div class="paragraph data-line-20">
<p>そもそも、値の書き換えってなんでしょうか？</p>
</div>
<div class="paragraph data-line-22">
<p>純粋関数型プログラミングは、純粋に数学的なプログラミングです。</p>
</div>
<div class="paragraph data-line-24">
<p>値A = 1</p>
</div>
<div class="paragraph data-line-26">
<p>というのがあるとします。</p>
</div>
<div class="paragraph data-line-28">
<p>この値を書き換える、っていうのは、</p>
</div>
<div class="paragraph data-line-30">
<p>値A= 2</p>
</div>
<div class="paragraph data-line-32">
<p>とかにするということですよね？</p>
</div>
<div class="paragraph data-line-34">
<p>これ、数学的には破綻しています。義務教育を受けていれば誰でもすぐにわかることです。</p>
</div>
<div class="paragraph data-line-36">
<p>もしくは、「いやこれはプログラミング特有の代入なんで、数学的には破綻していない！」というのであれば、「数学とは違うプログラミング特有のまた別のなにかの概念」を暗黙に導入しながら数学的ではない方法を採用している、ということなので、いずれにせよ純粋に数学的なプログラミングはやってない、ということになります。</p>
</div>
<div class="paragraph data-line-38">
<p>純粋関数型プログラミングあるいは単に関数型プログラミングではない、（原始的な）命令型プログラミング のパラダイムでは、このような数学的に破綻した作法が当然のようにまかりとおっています。</p>
</div>
<div class="paragraph data-line-40">
<p>しかし数学的に破綻しているのは、数学的な作業であるプログラミングではかなりマズいわけなので、こういう値を書き換える真似は避けよう、とすれば「値の不変性」、英語で言えばイミュータブル(immutable)という関数型プログラミング御用達の概念となります。</p>
</div>
<div class="paragraph data-line-42">
<p>さて、ここで重大な問題が発生してしまいます。「現実世界」ってのはmutableです。現実世界というのは刻一刻と変化していきます。数学的整合性のあるimmutableで一貫したプログラミングなんぞは机上の空論で、だから関数型プログラミングなんて理想論は現実的なアプリケーションを開発するのには使いものにはならない、と思われがちというか、実際にそう思われていた時期も長かったように思います。</p>
</div>
</div>
<div class="sect2 data-line-44">
<h3 id="_世界モデル数学と物理学と時間">3.2. 世界モデル　数学と物理学と時間</h3>
<div class="paragraph data-line-46">
<p>整理すると、</p>
</div>
<div class="paragraph data-line-48">
<p>現実世界 mutable<br>
数学世界 immutable<br>
こういうマインドセットがまずあるわけです。</p>
</div>
<div class="paragraph data-line-52">
<p>両者は一致しません、じゃあどうしよう？</p>
</div>
<div class="paragraph data-line-54">
<p>原始的な命令型パラダイム、あるいはオブジェクト指向の大半の作法では、我々の素朴な直感に忠実に従って、数学世界のほうを捻じ曲げて、</p>
</div>
<div class="paragraph data-line-56">
<p>現実世界 mutable
似非数学世界 mutable
とします。これで現実世界と似非数学世界の一致となりました。</p>
</div>
<div class="paragraph data-line-60">
<p>似非数学世界、っていうのは</p>
</div>
<div class="paragraph data-line-62">
<p>値A = 1</p>
</div>
<div class="paragraph data-line-64">
<p>値A= 2</p>
</div>
<div class="paragraph data-line-66">
<p>みたいな並びを普通に許容する、コードの並び方に完全に依存して論理が決まっていく世界です。数学っていうよりもコードの並び方のほうが重要なんです。</p>
</div>
<div class="paragraph data-line-68">
<p>この、似非数学世界での各種操作が旧来の意味での原始的なプログラミングの作法である、と言えるでしょう。数学的不整合についてはその都度ごまかしごまかしやっていくわけです。</p>
</div>
<div class="paragraph data-line-70">
<p>根本的に何かが間違っている。何か見落としている。それは「時間」の概念です。</p>
</div>
<div class="paragraph data-line-72">
<p>とても不思議な現象として、世のほとんどすべてのプログラマは「時間」についてはまるで語りたがりません。まるで、そんなことはプログラミングの範疇外であるかのようにガン無視しています。とても大事なことなんですけどね。</p>
</div>
<div class="paragraph data-line-74">
<p>だって、きちんと時間の概念を導入してやれば、</p>
</div>
<div class="paragraph data-line-76">
<p>時間t1,t2で</p>
</div>
<div class="paragraph data-line-78">
<p>値A(t1) = 1</p>
</div>
<div class="paragraph data-line-80">
<p>値A(t2)= 2</p>
</div>
<div class="paragraph data-line-82">
<p>とできて、数学的に破綻しなくなるじゃないですか？それだけのことです。</p>
</div>
<div class="paragraph data-line-84">
<p>これだとコードの並びに依存しません、入れ替わったって別に大丈夫です。純粋に数学的だと言えます。</p>
</div>
<div class="paragraph data-line-86">
<p>でもそういう風にここで、あるいは別のところでも、プログラミングのトピックで自分がこぞって「時間」について語ろうとすると、「なんかまた独自思想でポエムを語ってるやつがいる」というのが予想されうるプログラミング界隈の通常の反応でしょう。なぜか話が通じません。これまでこの手の話を書いたら何度も炎上させられました（笑　非常に愚かなことですがそれが現実です。</p>
</div>
<div class="paragraph data-line-88">
<p>そこで、今から「権威」を引用します。知的な活動としては本来は推奨されない権威主義ですが、少なくとも権威の下では連中は無駄な文句は言わず黙ってくれるのでとても助かります。</p>
</div>
<div class="paragraph data-line-90">
<p>関数型プログラミングの界隈でバイブル化されている計算機プログラムの構造と解釈(SICP)を引用しましょう。</p>
</div>
<div class="imageblock data-line-92">
<div class="content">
<img src="./img/2-12-2020-17-02-00-PM.png" alt="2 12 2020 17 02 00 PM">
</div>
</div>
<div class="paragraph data-line-95">
<p>SICPが優れている理由のひとつには、このテクストにはちゃんと物理学の視点があることです。つまり「この現実世界のこと」をちゃんと論じてくれています。この要素に触れているプログラミング書籍は非常に稀です。</p>
</div>
<div class="paragraph data-line-97">
<p>関数型プログラミングと時間の関係について秀逸な視点が強調されているのですが、この本はやたらバイブル化されてるわりに、そこで論じられている時間の視点について、きちんと評価して論評されているのはほとんど見たことがありません。それだけ世のプログラマというのはプログラムと時間の概念を結びつけて語るのが苦手、というか嫌いなのでしょう。</p>
</div>
<div class="paragraph data-line-99">
<p>以下、長いですが、随時太字にしながら読む価値が大きいところを引用します。訳にはずいぶんと不満がありますが、今回は許容することにします。ただ要所でこれはさすがにまずいと感じる文は適時翻訳しなおしています。</p>
</div>
<div class="paragraph data-line-101">
<p>引用文中に頻出する「代入」というのは、ここで問題となっている値の書き換えのこと＝命令型プログラミングのいわゆるmutableな「破壊的代入」のことです。</p>
</div>
<div class="paragraph data-line-104">
<p><a href="http://vocrf.net/docs_ja/jsicp.pdf" class="bare">http://vocrf.net/docs_ja/jsicp.pdf</a></p>
</div>
<div class="listingblock data-line-109">
<div class="content">
<pre>3.5 ストリーム

ここまでで、モデル化の道具としての代入について十分理解し、また代入が引き起こす複雑な問題も認識できました。このあたりで、私たちがもし別の取り組み方をしていたら、これらの問題のいくつかは避けられたのではないかということを考えてみてもいいころです。この節では、状態をモデル化する別のアプローチについて検討します。このアプローチは、ストリーム (stream) と呼ばれるデータ構造に基づくものです。ここから先で見ていくように、状態をモデル化する際に生じる複雑性の一部をストリームによって軽減できます。

一歩下がって、この複雑性というものがどこから来ているのか再検討してみましょう。現実世界の現象をモデル化しようとする中で、見たところもっともな決定をいくつかしてきました。局所状態を持つ現実世界のオブジェクトを局所変数を持つ計算オブジェクトによってモデル化し、現実世界の時間の変化をコンピュータ上の時間変化と同一視し、コンピュータ上のモデルオブジェクトの状態の経時変化はモデルオブジェクトの局所変数に対する代入として実装しました。

ほかのアプローチはないのでしょうか。モデル対象の世界での時間とコンピュータ上の時間を同一視することは避けられないのでしょうか。変化する世界での現象をモデル化するには、時間とともにモデルを変化させるしかないのでしょうか。この問題について、数学関数を使って考えてみましょう。量 x の時間によって変化するふるまいは、時間の関数 x(t) として記述できます。もし時刻ごとの x に注目するなら、それを変化する量として捉えることになります。しかし、全時間を通しての値の履歴に注目するなら、変化については重要視しないことになります。関数そのものは変化しないことになるからです。（物理学では、運動について考える手段として粒子の “世界線” を導入することによって、この見方を採用することがあります。）

もし時間を離散ステップで測るのであれば、時間関数は (無限かもしれない) 列としてモデル化できます。この節では、モデル化対象システムの時間履歴を表現する列によって変化をモデル化する手法について見ていきます。これを達成するために、ストリーム (stream) と呼ばれる新しいデータ構造を導入します。抽象的な視点から見ると、ストリームはただの列です。しかし、ストリームを (2.2.1 節のように) 素直にリストとして実装したものでは、ストリーム処理の本来の力が見えてきません。その代わりに、ここでは遅延評価 (delayed evaluation) というテクニックを導入します。遅延評価を使うことによって、非常に大きな (無限でもありうる) 列をストリームして表現することが可能になります。

ストリーム処理によって、状態のあるシステムを代入や可変データを使わずにモデル化できるようになります。このことは、論理的にも実用的にも大きな意味があります。代入の導入につきもののマイナス点を避けてモデルを構築できるからです。

時間の関数型プログラミング的視点

ここで、この章の初めで提起したオブジェクトと状態の問題に戻って、これらの問題を新しい観点から検討してみましょう。この章の初めでは代入と可変オブジェクトを導入し、状態を持つシステムをモデル化するプログラムをモジュール式に構築するメカニズムを提供しました。また、局所変数を持つ計算オブジェクトを構築し、これらの変数を代入によって変更しました。そして、この世界に存在するオブジェクトの経時的なふるまいを、対応する計算オブジェクトの経時的なふるまいによってモデル化しました。

その後、ストリームを使うことによっても、局所状態を持つオブジェクトをモデル化できるということを見てきました。オブジェクトの局所状態のような変化していく量は、逐次的な状態の時間履歴を表現するストリームによってモデル化できます。本質的に、ストリームによって時間を明示的に表現することによって、シミュレートされた世界の中での時間と、評価の間に起こるイベントの順番とを切り離すということをしていることになります。実際に、delayというものが存在するので、モデル中のシミュレートされた時間と、評価の間に起こるイベントの順番との間に、ほとんど関係がないということもありえます。

（引用中略）

stream-withdraw は、出力が入力によって完全に決定される、明確に定義された数学関数を実装しています。しかし、ここで入力 amount-stream がユーザーのタイプする一連の値のストリームで、結果の残高ストリームは画面に表示されていると考えてみてください。そうすると、値をタイプし結果を見ているユーザーの視点からは、このストリーム処理は make-simplified-withdraw によって作られたオブジェクトと同じふるまいを持っていることになります。しかしストリーム版では、代入も局所状態もなく、このため3.1.3 節で直面したような理論的な困難もありません。それなのに、システムには状態があるのです！

これはかなりすごいことです。stream-withdraw は、ふるまいが変わったりしない明確に定義された数学関数を実装しているにもかかわらず、ここでのユーザーの知覚は、変化する状態を持つシステムと対話しているときと同じなのです。このパラドックスを解くひとつの見方は、ユーザの時限的な存在性こそが、システムには状態がある、ということを強制している、ということです。もしユーザーがシステムとの対話から一歩下がって、個々の取引ベースで考えるのをやめて残高のストリームという考え方をするなら、システムは状態を持たないように見えるでしょう。

複雑な処理のある一部から見ると、ほかの部分は時間とともに変化するように見えます。それらは時間によって変わる局所状態を持っています。私たちの世界に存在するこの種の自然な分解方法 (これは、私たちが世界の一部としての視点から世界を見るやり方と同じです) をモデル化したプログラムをコンピュータ中の構造を使って書こうと思うと、関数的でない計算オブジェクトを作ることになります。オブジェクトは変化しなければならないからです。状態は局所状態変数によってモデル化し、状態の変更はこれらの変数に対する代入によってモデル化します。こうすることによって、計算実行の時間が私たちのいるこの世界の時間をモデル化するようにします。その結果、コンピュータの中に “オブジェクト” ができることになります。

オブジェクトを使ったモデル化は強力で直感的です。その大きな理由となっているのは、このやり方が私たちがこの世界と関わる際の認知にマッチしているということです。しかし、この章を通して何度も見てきたように、これらのモデルは、イベント順の制約や、複数プロセスの同期といった、厄介な問題を引き起こします。

関数型プログラミング言語 (functional programming language) の発展は、これらの問題を避けられるという見込みによって促進されてきました。関数型プログラミング言語は代入や変更可能なデータを提供しません。このような言語では、すべての手続きは引数に対する明確な数学関数を実装することになり、挙動は変化しません。並列システムを扱うには、関数型のアプローチは非常に魅力的です。

（物理でも同じように、動く粒子を観測しているとき、粒子の位置 (状態) は変化していると言われるでょう。しかし、時空の中での粒子の世界線という視点からは、変化というものは存在しません。）</pre>
</div>
</div>
<div class="paragraph data-line-143">
<p>ここで、</p>
</div>
<div class="paragraph data-line-145">
<p>「オブジェクトを使ったモデル化」というのは、もちろん（原始的）命令型プログラミング、あるいは普通に宣言型パラダイムでもなんでもないタイプのオブジェクト指向のことで、直感的、私たちがこの世界と関わる際の認知にマッチしている、コンピュータ上のモデルオブジェクトの状態の経時変化はモデルオブジェクトの局所変数に対する代入として実装、代入が引き起こす複雑な問題がある</p>
</div>
<div class="paragraph data-line-147">
<p>現実世界 mutable<br>
似非数学世界 mutable<br>
他方で、</p>
</div>
<div class="paragraph data-line-151">
<p>「ストリーム処理によって、状態のあるシステムを代入や可変データを使わずにモデル化」とは関数型リアクティブプログラミング（Functional reactive programming/FRP）のことです。</p>
</div>
<div class="paragraph data-line-153">
<p>時間の関数型プログラミング的視点</p>
</div>
<div class="paragraph data-line-155">
<p>関数型プログラミング言語 (functional programming language) の発展は、これらの問題を避けられるという見込みによって促進されてきました。関数型プログラミング言語は代入や変更可能なデータを提供しません。←数学世界 immutable</p>
</div>
<div class="paragraph data-line-157">
<p>量 x の時間によって変化するふるまいは、時間の関数 x(t) として記述</p>
</div>
<div class="paragraph data-line-159">
<p>（物理でも同じように、動く粒子を観測しているとき、粒子の位置 (状態) は変化していると言われるでょう。しかし、時空の中での粒子の世界線という視点からは、変化というものは存在しません。）</p>
</div>
<div class="paragraph data-line-161">
<p>つまり、</p>
</div>
<div class="paragraph data-line-163">
<p>現実世界 immutable<br>
数学世界 immutable<br>
と、現実世界も数学・物理学的な俯瞰では、なんのことはないimmutableである、と統合してしまいます。</p>
</div>
<div class="paragraph data-line-167">
<p>これは、理論物理学の素養があれば、ごく普通の世界観でしょう。</p>
</div>
<div class="imageblock data-line-169">
<div class="content">
<img src="./img/2-12-2020-17-06-53-PM.png" alt="2 12 2020 17 06 53 PM">
</div>
</div>
<div class="paragraph data-line-171">
<p><a href="https://www.amazon.co.jp/Stubbornly-Persistent-Illusion-Essential-Scientific/dp/076243564X">A Stubbornly Persistent Illusion: The Essential Scientific Works of Albert Einstein | スティーブン・ホーキング</a></p>
</div>
<div class="literalblock data-line-173">
<div class="content">
<pre>The distinction between the past, present and future is only a stubbornly persistent illusion.
過去、現在、未来の区別というのは、頑固につきまとう幻想に過ぎない
- アルバート・アインシュタイン</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4">
<h2 id="_frpスプレッドシート">4. FRP　スプレッドシート</h2>
<div class="sectionbody">
<style type="text/css">
p >code {background-color: #aaaaaa};
td >code {background-color: #aaaaaa};
</style>
<div class="admonitionblock caution data-line-16">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph data-line-17">
<p>完成から程遠い　10％以下　のドキュメント</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2 data-line-21">
<h3 id="_永続データ構造_たとえばgitとか">4.1. 永続データ構造 たとえばGitとか</h3>
<div class="paragraph data-line-23">
<p><a href="https://ja.wikipedia.org/wiki/%E6%B0%B8%E7%B6%9A%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0">永続データ構造</a></p>
</div>
<div class="paragraph data-line-26">
<p><a href="https://en.wikipedia.org/wiki/Persistent_data_structure">Persistent data structure</a></p>
</div>
<div class="literalblock data-line-29">
<div class="content">
<pre>永続データ構造（えいぞくデータこうぞう、英: Persistent data structure）は、変更される際に変更前のバージョンを常に保持するデータ構造である。このようなデータ構造は、更新の際に元のデータ構造を書き換えるのではなく、新たなデータ構造を生成すると考えられ、イミュータブルなデータ構造の構築に利用可能である。</pre>
</div>
</div>
<div class="paragraph data-line-32">
<p>永続データ構造というのは、簡単に言い表すと「データの足し算」という算術、代数構造の操作です。</p>
</div>
<div class="paragraph data-line-34">
<p>たとえば、文字列の接続</p>
</div>
<div class="paragraph data-line-36">
<p>"AB" + "C" = "ABC"</p>
</div>
<div class="paragraph data-line-38">
<p>という式は、２つの文字列を接続した結果、新しい文字列というデータ構造が生成されていると言えます。</p>
</div>
</div>
<div class="sect2 data-line-42">
<h3 id="_巷で非同期処理と呼ばれるものの正体">4.2. 巷で「非同期処理」と呼ばれるものの正体</h3>
<div class="paragraph data-line-44">
<p>「非同期処理」という言葉は需要の高い言葉です。</p>
</div>
<div class="paragraph data-line-46">
<p>この言葉はご覧のとおり「同期処理」という概念の否定形というか対立概念で、ベースには、「同期処理」という概念があります。</p>
</div>
<div class="paragraph data-line-48">
<p>そして「同期処理」とは、なんのことはない命令型プログラミングのフローのことでしかありません。</p>
</div>
</div>
<div class="sect2 data-line-51">
<h3 id="_promise">4.3. Promise</h3>

</div>
<div class="sect2 data-line-54">
<h3 id="_時間軸マッピング">4.4. 時間軸マッピング</h3>
<div class="listingblock data-line-58">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">[1,2,3,4,5] map f

setInterval(f, 1000);

intervalStream(1000) map f</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-69">
<h3 id="_スプレッドシートのようにコーディングする">4.5. スプレッドシートのようにコーディングする</h3>

</div>
<div class="sect2 data-line-71">
<h3 id="_依存関係を解決する">4.6. 依存関係を解決する</h3>

</div>
<div class="sect2 data-line-73">
<h3 id="_reactive_functor">4.7. Reactive Functor</h3>
<div class="paragraph data-line-75">
<p>解説</p>
</div>
<div class="listingblock data-line-79">
<div class="title">Reactive Functor</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">{
  const identity = a =&gt; a;
  const right = a =&gt; b =&gt; b;
  const log = msg =&gt; right
    (console.log(msg))
    (msg);
  const undefinedCheck = a =&gt; (a == null);// ==
  const optionMap = f =&gt; a =&gt;
    undefinedCheck(a)
      ? undefined
      : f(a);

  {
    "----test"|&gt;log;

    const register = f =&gt;
      A =&gt; // register(f): A =&gt; B
        (B =&gt; right
          (A.list = //mutable
            A.list//add B-function to A-list
              .concat(a =&gt; B|&gt; trigger(a |&gt; optionMap(f))))
          (B|&gt; trigger(A.lastVal |&gt; optionMap(f)))
        )(IO(undefined)) //B = new IO

    const trigger = a =&gt;
      A =&gt; right(right
        (A.lastVal = a) //mutable
        (A.list.map(f =&gt; a |&gt; optionMap(f)))//trigger f in list
      )(A);

    //spreadsheel cell corresponds to IO
    const IO = a =&gt; ({
      lastVal: a, //mutable
      list: [] //mutable
    });

    const A = IO(undefined);

    const B = A
      |&gt; register(a =&gt; a * 2)
      |&gt; register(log);

    const C = A |&gt; register(log);

    A |&gt; trigger(3)
      |&gt; trigger(5);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-134">
<h3 id="_reactive_monad">4.8. Reactive Monad</h3>
<div class="listingblock data-line-138">
<div class="title">Reactive Monad</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">{
  const identity = a =&gt; a;
  const right = a =&gt; b =&gt; b;
  const log = msg =&gt; right
    (console.log(msg))
    (msg);
  const undefinedCheck = a =&gt;
    (a === undefined) || (a === null);
  const optionMap = f =&gt; a =&gt;
    undefinedCheck(a)
      ? undefined
      : f(a);

  "----reactive monad!"|&gt;log;

  const customOperator = op =&gt; f =&gt; set =&gt;
    Object.defineProperty(set, op, {
      value: function (a) {
        return f(a)(this);
      }
    });//returns new set/object

  const flatRegister = f =&gt;
    A =&gt; // flatRegister(f): A =&gt; B
      (B =&gt; right
        (A.list = //mutable
          A.list//add B-function to A-list
            .concat(a =&gt; B|&gt; flatTrigger(a |&gt; optionMap(f))))
        (B|&gt; flatTrigger(A.lastVal |&gt; optionMap(f)))
      )(IO(undefined)) //B = new IO

  const flatTrigger = a =&gt; A =&gt;
    (aObject =&gt; // object | IO
      "lastVal" in aObject  //pattern match
        ? A|&gt; trigger(aObject.lastVal) //flat TTX=TX
        : A|&gt; trigger(a)
    )(Object(a)); //primitive is wrapped into object

  const trigger = a =&gt;
    A =&gt; right(right
      (A.lastVal = a) //mutable
      (A.list.map(f =&gt; a |&gt; optionMap(f)))//trigger f in list
    )(A);

  //spreadsheel cell corresponds to IO
  //the last element of infinite list (git)
  //https://en.wikipedia.org/wiki/Persistent_data_structure
  const IO = a =&gt; ({
    lastVal: a, //mutable
    list: [] //mutable
  })
    |&gt; customOperator('&gt;&gt;')(flatRegister);

  const next = flatTrigger;

  "============================"|&gt;log;

  const stream = IO("hello");

  const logStream = stream['&gt;&gt;'](log);

  stream |&gt; next("world");
  stream |&gt; next("!!");

  const A = IO(undefined);

  const B = A
  ['&gt;&gt;'](a =&gt; a * 2)
  ['&gt;&gt;'](log);

  const C = A['&gt;&gt;'](log);

  A |&gt; next(3)
    |&gt; next(5);


  Function.prototype |&gt;
    customOperator('.')
      (g =&gt; f =&gt; x =&gt; x |&gt; f |&gt; g);
  Function.prototype |&gt;
    customOperator('..')
      (g =&gt; f =&gt; x =&gt; IO(x)['&gt;&gt;'](f)['&gt;&gt;'](g));

  {
    "============================"|&gt;log;
    "==monad laws================"|&gt;log;
    "============================"|&gt;log;

    {
      "associativity------"|&gt;log;

      const f1 = a =&gt; a * 2;
      const f2 = a =&gt; a + 1;
      {
        IO(1)['&gt;&gt;'](f1)['&gt;&gt;'](f2)
        ['&gt;&gt;'](log);
      }
      {//endofunctor
        IO(1)['&gt;&gt;'](x =&gt; x|&gt; f1|&gt; f2)
        ['&gt;&gt;'](log);

        IO(1)['&gt;&gt;']((f1)['.'](f2))
        ['&gt;&gt;'](log);
      }
      {
        IO(1)['&gt;&gt;'](x =&gt; IO(x)['&gt;&gt;'](f1)['&gt;&gt;'](f2))
        ['&gt;&gt;'](log);

        IO(1)['&gt;&gt;']((f1)['..'](f2))
        ['&gt;&gt;'](log);
      }
      {//composition is point free
        "monad composition"|&gt; log;

        const io1 =
          IO['..'](f1)['..'](f2)['..'](log);

        1 |&gt; io1;

        const io2 =
          (f1)['..'](f2)['..'](log);

        1 |&gt; io2;

        const io3 =
          (f1)['..'](f2)['..'](log)['..'](IO);

        1 |&gt; io3;
      }
    }
    {
      "associativity Monad Function------"|&gt;log;

      const f1 = a =&gt; IO(a * 2);
      const f2 = a =&gt; IO(a + 1);
      {
        IO(1)['&gt;&gt;'](f1)['&gt;&gt;'](f2)
        ['&gt;&gt;'](log);
      }
      {
        IO(1)['&gt;&gt;'](x =&gt; IO(x)['&gt;&gt;'](f1)['&gt;&gt;'](f2))
        ['&gt;&gt;'](log);

        IO(1)['&gt;&gt;']((f1)['..'](f2))
        ['&gt;&gt;'](log);
      }
    }
    {
      "associativity Monad Function Monad value------"|&gt;log;

      const f1 = a =&gt; a['&gt;&gt;'](a =&gt; IO(IO(a * 2)));
      const f2 = a =&gt; a['&gt;&gt;'](a =&gt; IO(IO(a + 1)));
      const a = IO(1);
      {
        IO(a)['&gt;&gt;'](f1)['&gt;&gt;'](f2)
        ['&gt;&gt;'](log)['&gt;&gt;'](log);
      }
      {
        IO(a)['&gt;&gt;'](x =&gt; IO(x)['&gt;&gt;'](f1)['&gt;&gt;'](f2))
        ['&gt;&gt;'](log)['&gt;&gt;'](log);

        IO(a)['&gt;&gt;']((f1)['..'](f2))
        ['&gt;&gt;'](log)['&gt;&gt;'](log);
      }
    }
    {
      "idientiry left-right-- m * f ----"|&gt;log;

      const f = a =&gt; IO(a * 2);

      //left  e * f = f
      const left = 1 |&gt;
        (IO)['..'](f);

      //center  f
      const center = 1 |&gt;
        f;

      //right  m * e = m
      const right = 1 |&gt;
        (f)['..'](IO);

      left['&gt;&gt;'](log);
      center['&gt;&gt;'](log);
      right['&gt;&gt;'](log);
    }
  }

  {
    "equations ------"|&gt;log;

    const a = IO(1);

    const b = a['&gt;&gt;'](a =&gt; a * 2);

    const c =
      a['&gt;&gt;'](a =&gt;
        b['&gt;&gt;'](b =&gt; a + b));

    const aLog = a['&gt;&gt;'](log);
    const bLog = b['&gt;&gt;'](log);
    const cLog = c['&gt;&gt;'](log);

    a|&gt; next(10);
    a|&gt; next(100);

  }

  {
    const map = 'map';
    const a = [1, 2, 3];

    a[map](a =&gt; a * 2)
      |&gt; log;
  }

  {
    "timeStream -&gt; consoleStream ------" |&gt; log;

    const options = {
      year: 'numeric', month: 'numeric', day: 'numeric',
      hour: 'numeric', minute: 'numeric', second: 'numeric',
      hour12: false,
    };

    const currentTime = () =&gt;
      new Intl.DateTimeFormat('en-US', options).format(Date.now())

    const timeStream = IO(undefined);
    const f = () =&gt;
      timeStream |&gt; next(currentTime());
    setInterval(f, 1000);

    const consoleStream = timeStream['&gt;&gt;'](log);
  }


  {
    IO("dummy")[`&gt;&gt;`](task1)[`&gt;&gt;`](task2)[`&gt;&gt;`](task3);

    const tasks = (task1)[`.`](task2)[`.`](task3);

    IO("dummy")[`&gt;&gt;`](tasks);


    //Persistent data structure
    const ab = "ab";
    const abc = ab + "c";

    [1];

    [1].concat(2);

    [1].concat(2).concat(3);

    [1].concat(2).concat(3).concat(4);

    const A = IO(undefined);
    const B = A[`&gt;&gt;`](a =&gt; a * 2);

    const logger = B[`&gt;&gt;`](log);

    A
      |&gt; next(1)
      |&gt; next(2)
      |&gt; next(3);
    // A.concat(1).concat(2).concat(3)

  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<h1 id="_unit_3_数学_mathematics" class="sect0 data-line-110">🟧 UNIT 3 : 数学 Mathematics</h1>
<div class="sect1 data-line-1">
<h2 id="_代数的構造">1. 代数的構造</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="admonitionblock caution data-line-24">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph data-line-25">
<p>完成から程遠い　10％以下　のドキュメント</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-33">
<p><a href="https://www.britannica.com/science/algebra/Structural-algebra" class="bare">https://www.britannica.com/science/algebra/Structural-algebra</a></p>
</div>
<div class="paragraph data-line-35">
<p>Structural Algebra
At the turn of the 20th century, algebra reflected a very clear conceptual hierarchy based on a systematically elaborated arithmetic, with a theory of polynomial equations built on top of it. Finally, a well-developed set of conceptual tools, most prominently the idea of groups, offered a comprehensive means of investigating algebraic properties.</p>
</div>
<div class="paragraph data-line-38">
<p>構造代数
20世紀の変わり目には、代数学は、体系的に精緻化された算術に基づく明確な概念的階層を反映しており、その上に多項式の理論が構築されていた。最終的には、群の概念を中心とした概念ツールが発達し、代数的性質を調べるための包括的な手段が提供された。</p>
</div>
</div>
</div>
<div class="sect1 data-line-1">
<h2 id="_結合性associativityとモノイドmonoid">2. 結合性(associativity)とモノイド(monoid)</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="admonitionblock caution data-line-24">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph data-line-25">
<p>完成から程遠い　10％以下　のドキュメント</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-2">
<h2 id="function">3. 関数を知ろう</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="paragraph data-line-23">
<p>世界は関数で満ちあふれている・・・</p>
</div>
<div class="paragraph data-line-25">
<p>なにはともあれ、まず関数(function)のことを知ろう。</p>
</div>
<div class="sect2 data-line-29">
<h3 id="know_function">3.1. 関数</h3>
<div class="paragraph data-line-31">
<p><a href="https://www.britannica.com/science/function-mathematics" class="bare">https://www.britannica.com/science/function-mathematics</a></p>
</div>
<div class="paragraph data-line-33">
<p><strong>Function</strong>, in mathematics, an expression, rule, or law that defines a relationship between one variable (the independent variable) and another variable (the dependent variable). Functions are ubiquitous in mathematics and are essential for formulating physical relationships in the sciences. The modern definition of function was first given in 1837 by the German mathematician Peter Dirichlet: This relationship is commonly symbolized as y = f(x).</p>
</div>
<div class="paragraph data-line-35">
<p>数学における<strong>関数</strong>とは、ある変数（独立変数）ともう一つの変数（従属変数）との間の関係を定義する式、ルール、または法則です。関数は数学の至る所にあり、科学における物理的な関係を定式化するために必要不可欠です。現代の関数の定義は、1837年にドイツの数学者Peter Dirichletによって最初に与えられました。この関係は、一般的に y = f（x）として表記されます。</p>
</div>
<div class="paragraph data-line-38">
<p><a href="https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E9%96%A2%E4%BF%82bi" class="bare">https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E9%96%A2%E4%BF%82bi</a></p>
</div>
<div class="paragraph data-line-40">
<p>関係の特別な場合として写像がある</p>
</div>
</div>
<div class="sect2 data-line-42">
<h3 id="_関数の具体例">3.2. 関数の具体例</h3>
<div class="paragraph data-line-44">
<p>関数とはいったいどういうものなのか？具体例を見ていくとわかりやすいでしょう。</p>
</div>
<div class="sect3 data-line-46">
<h4 id="_国をインプットしたらその首都をアウトプットする_首都関数">3.2.1. 国をインプットしたらその首都をアウトプットする <code>首都関数</code></h4>
<div class="imageblock data-line-48">
<div class="content">
<img src="./img/2-7-2020-12-40-51-PM.png" alt="2 7 2020 12 40 51 PM">
</div>
</div>
<div class="imageblock data-line-50">
<div class="content">
<img src="./img/2-7-2020-12-43-43-PM.png" alt="2 7 2020 12 43 43 PM">
</div>
</div>
</div>
<div class="sect3 data-line-52">
<h4 id="_国をインプットしたらその通貨をアウトプットする_通貨関数">3.2.2. 国をインプットしたらその通貨をアウトプットする <code>通貨関数</code></h4>
<div class="imageblock data-line-54">
<div class="content">
<img src="./img/2-7-2020-12-44-49-PM.png" alt="2 7 2020 12 44 49 PM">
</div>
</div>
</div>
<div class="sect3 data-line-56">
<h4 id="_英単語をインプットしたらその日本語をアウトプットする_英和関数">3.2.3. 英単語をインプットしたらその日本語をアウトプットする <code>英和関数</code></h4>
<div class="imageblock data-line-58">
<div class="content">
<img src="./img/2-7-2020-12-46-18-PM.png" alt="2 7 2020 12 46 18 PM">
</div>
</div>
<div class="imageblock data-line-60">
<div class="content">
<img src="./img/2-7-2020-12-48-57-PM.png" alt="2 7 2020 12 48 57 PM">
</div>
</div>
<div class="paragraph data-line-62">
<p>英和辞書や和英辞書も関数の一種です。</p>
</div>
<div class="paragraph data-line-64">
<p>もちろん最近では、Google翻訳とかになっています。</p>
</div>
</div>
<div class="sect3 data-line-66">
<h4 id="_google検索も関数">3.2.4. Google検索も関数</h4>
<div class="paragraph data-line-68">
<p>Googleの検索エンジンは巨大なデータベースで、膨大なWeb記事がランキングされてストックされています。<br>
Google検索も、検索ワードがインプット、検索結果がアウトプットの関数です。</p>
</div>
<div class="imageblock data-line-71">
<div class="content">
<img src="./img/2-7-2020-12-51-01-PM.png" alt="2 7 2020 12 51 01 PM">
</div>
</div>
<div class="paragraph data-line-73">
<p>「必ず答えを返してくるやつ」です。</p>
</div>
</div>
<div class="sect3 data-line-75">
<h4 id="_aiも関数">3.2.5. AIも関数</h4>
<div class="sect4 data-line-77">
<h5 id="_コンピュータビジョン機械学習ai">コンピュータビジョン（機械学習・AI）</h5>
<div class="imageblock data-line-79">
<div class="content">
<img src="./img/2-7-2020-12-55-19-PM.png" alt="2 7 2020 12 55 19 PM">
</div>
</div>
<div class="paragraph data-line-81">
<p>事前に数万以上の手書き画像のデータを使って、アウトプット精度の高い関数を学習させておく（<a href="https://ja.wikipedia.org/wiki/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92">機械学習</a>）。</p>
</div>
<div class="imageblock data-line-83">
<div class="content">
<img src="./img/00-mnist.png" alt="00 mnist">
</div>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-86">
<h3 id="_関数のテーブル">3.3. 関数のテーブル</h3>
<div class="paragraph data-line-88">
<p>簡単な構造の関数はテーブル（表）で表現できます。</p>
</div>
<div class="paragraph data-line-90">
<p>Google検索やAI(機械学習)のコンピュータビジョンの関数はテーブルで表現するのは極めて困難でしょう。</p>
</div>
<div class="sect4 data-line-92">
<h5 id="_首都関数">首都関数</h5>
<table class="tableblock frame-all grid-all data-line-94" style="width: 80%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">インプット</th>
<th class="tableblock halign-center valign-top">アウトプット</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">イギリス</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">ロンドン</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">日本</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">東京</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">フランス</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">パリ</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">アメリカ</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">ワシントンD.C.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4 data-line-110">
<h5 id="_通貨関数">通貨関数</h5>
<table class="tableblock frame-all grid-all data-line-112" style="width: 80%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">インプット</th>
<th class="tableblock halign-center valign-top">アウトプット</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">イギリス</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">UKポンド</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">日本</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">円</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">フランス</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">ユーロ</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">アメリカ</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">USドル</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4 data-line-128">
<h5 id="_英和関数">英和関数</h5>
<table class="tableblock frame-all grid-all data-line-130" style="width: 80%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">インプット</th>
<th class="tableblock halign-center valign-top">アウトプット</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">CAT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">猫</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">DOG</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">犬</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">WATER</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">水</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">BICYCLE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">自転車</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4 data-line-147">
<h5 id="_気温関数">気温関数</h5>
<div class="paragraph data-line-149">
<p>「気温　東京　年間」でGoogle検索すると、「過去の平均気温」という「データベース系の関数のテーブル」が出てきます。</p>
</div>
<div class="imageblock text-left data-line-151">
<div class="content">
<img src="./img/00-temp-tokyo.png" alt="00 temp tokyo">
</div>
</div>
<div class="paragraph data-line-153">
<p>よく見ると、<strong>グラフというタブも用意されています。</strong></p>
</div>
</div>
<div class="sect4 data-line-155">
<h5 id="_気温関数グラフ">気温関数(グラフ)</h5>
<div class="imageblock text-left data-line-157">
<div class="content">
<img src="./img/00-temp-tokyo-graph.png" alt="00 temp tokyo graph">
</div>
</div>
<div class="paragraph data-line-159">
<p>このように、<br>
<strong>インプットが数値</strong><br>
<strong>アウトプットが数値</strong><br>
の場合、<br>
<strong>インプットをX軸</strong><br>
<strong>アウトプットをY軸</strong><br>
とした<strong>２次元平面上にプロット</strong>して、<strong>関数をグラフとして視覚化すれば便利なケース</strong>があります。</p>
</div>
<div class="paragraph data-line-167">
<p>念の為に繰り返しますが今まで見てきたように、<strong>関数はインプットとアウトプットがシンプルなテーブル(表)で表現できて、なおかつXY平面上にプロットが可能な数値であるとは限定されているわけではない</strong>ので、あくまで特別なケースでしかありません。</p>
</div>
</div>
</div>
<div class="sect2 data-line-170">
<h3 id="_数学法則を使う関数">3.4. 数学法則を使う関数</h3>
<div class="paragraph data-line-172">
<p>Google検索、それから手書き文字などを識別するコンピュータビジョンのAIも含め、過去に蓄積されたデータベースを利用する関数がある一方で、そのようなデータベースを利用しない関数もあります。</p>
</div>
<div class="paragraph data-line-174">
<p>数学法則を使う関数です。<strong>数学法則というのは、なぜか最初から存在しているので、蓄積しておくべきデータなどは必要がありません。</strong></p>
</div>
<div class="sect3 data-line-176">
<h4 id="_絶対値を求める関数">3.4.1. 絶対値を求める関数</h4>
<div class="imageblock data-line-178">
<div class="content">
<img src="./img/2-7-2020-12-59-12-PM.png" alt="2 7 2020 12 59 12 PM">
</div>
</div>
</div>
<div class="sect3 data-line-180">
<h4 id="_２倍する関数">3.4.2. ２倍する関数</h4>
<div class="imageblock data-line-182">
<div class="content">
<img src="./img/2-7-2020-13-04-25-PM.png" alt="2 7 2020 13 04 25 PM">
</div>
</div>
</div>
<div class="sect3 data-line-184">
<h4 id="_２倍する関数テーブル">3.4.3. ２倍する関数(テーブル)</h4>
<table class="tableblock frame-all grid-all data-line-187" style="width: 80%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">インプット</th>
<th class="tableblock halign-center valign-top">アウトプット</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-203">
<p>これは、気温のテーブルを二次元平面にプロットしてグラフにしたら役立ったのと同じ原理で、XY軸のグラフにできます。</p>
</div>
</div>
<div class="sect3 data-line-205">
<h4 id="_２倍する関数xy軸のグラフ">3.4.4. ２倍する関数(XY軸のグラフ)</h4>
<div class="imageblock data-line-207">
<div class="content">
<img src="./img/00-y2x.png" alt="00 y2x">
</div>
</div>
</div>
<div class="sect3 data-line-209">
<h4 id="_２倍する関数xy変数のテーブル">3.4.5. ２倍する関数(XY変数のテーブル)</h4>
<div class="paragraph data-line-211">
<p>どうせ、X軸とY軸の二次元平面にプロットすることも見越して、一石二鳥を狙うような感じで、数学世界の慣習で、</p>
</div>
<div class="paragraph data-line-213">
<p><strong>インプット側の数値の変数はXとする</strong><br>
<strong>アウトプット側の数値の変数はYとする</strong><br>
ということに暗黙の了解としてなっており、</p>
</div>
<table class="tableblock frame-all grid-all data-line-218" style="width: 80%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">X</th>
<th class="tableblock halign-center valign-top">Y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-234">
<p>というように、変数XとYのテーブルで関数表現がされたりします。</p>
</div>
</div>
<div class="sect3 data-line-236">
<h4 id="_２倍する関数xy変数の方程式">3.4.6. ２倍する関数(XY変数の方程式)</h4>
<div class="stemblock data-line-239">
<div class="content">
\[y = 2x\]
</div>
</div>
<div class="paragraph data-line-243">
<p>という方程式が関数になる、とヤブから棒に教えられることが多く、世の中学生や高校生が混乱しているようです。</p>
</div>
</div>
</div>
<div class="sect2 data-line-246">
<h3 id="_関数の表記">3.5. 関数の表記</h3>
<div class="paragraph data-line-248">
<p>いろんな関数が存在しています。</p>
</div>
<div class="paragraph data-line-250">
<p>検索エンジンの場合は、</p>
</div>
<div class="imageblock data-line-252">
<div class="content">
<img src="./img/2-7-2020-12-51-01-PM.png" alt="2 7 2020 12 51 01 PM">
</div>
</div>
<div class="paragraph data-line-254">
<p>で、和訳するための和英辞書もひっくるめて、もっと一般化して、</p>
</div>
<div class="paragraph data-line-256">
<p>データベースへのインプットとアウトプットのように表現できます。</p>
</div>
<div class="imageblock data-line-258">
<div class="content">
<img src="./img/2-7-2020-13-09-51-PM.png" alt="2 7 2020 13 09 51 PM">
</div>
</div>
<div class="paragraph data-line-260">
<p>事前のデータベースの用意が必要ない、あらかじめ存在する数学法則を使う関数もありました。</p>
</div>
<div class="imageblock data-line-262">
<div class="content">
<img src="./img/2-7-2020-13-04-25-PM.png" alt="2 7 2020 13 04 25 PM">
</div>
</div>
<div class="paragraph data-line-264">
<p>これも数式へのインプットとアウトプットのように表現できます。</p>
</div>
<div class="imageblock data-line-266">
<div class="content">
<img src="./img/2-7-2020-13-13-43-PM.png" alt="2 7 2020 13 13 43 PM">
</div>
</div>
<div class="paragraph data-line-268">
<p>いちいち、「インプット」「アウトプット」と書いてまわるのは大変なので、何でも良いですが、なんらかの簡潔な文字（数学の場合はたいていアルファベットかギリシャ文字）を割り当てて表現します。</p>
</div>
<div class="imageblock data-line-270">
<div class="content">
<img src="./img/2-7-2020-13-19-24-PM.png" alt="2 7 2020 13 19 24 PM">
</div>
</div>
<div class="paragraph data-line-273">
<p>関数の場合は、名前が何でも良いときは、関数（function）の頭文字のアルファベットの <code>f</code> が使われることが多く、「なんらかの関数」という意味で使われます。</p>
</div>
<div class="paragraph data-line-275">
<p>つまり、<code>f</code> は、首都関数かもしれないし、翻訳関数かもしれない、Google検索エンジンかもしれない、AIかもしれない、数式かもしれない。</p>
</div>
<div class="paragraph data-line-277">
<p>インプットは、慣例に従って <code>x</code> とすることが多いです。これも現状、なんらかの具体的な値が定まっているわけではありません。「インプット」という言葉の代わりに <code>x</code> と置き換えただけです。</p>
</div>
<div class="paragraph data-line-279">
<p>アウトプットも同様に、「アウトプット」という言葉の代わりに <code>y</code> と置き換えると、数値の場合はそのままxy平面にプロットしてグラフとして視覚化しやすくなるのは説明したとおりです。</p>
</div>
<table class="tableblock frame-all grid-all data-line-282" style="width: 80%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">インプット</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">アウトプット</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(y\)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-288">
<p>ただし歴史的に、もっとも一般的には、ある関数 <code>f</code> のアウトプットは</p>
</div>
<div class="imageblock data-line-290">
<div class="content">
<img src="./img/6-7-2020-21-26-22-PM.png" alt="6 7 2020 21 26 22 PM">
</div>
</div>
<div class="paragraph data-line-292">
<p>\(f(x)\)と表記します。</p>
</div>
<table class="tableblock frame-all grid-all data-line-295" style="width: 80%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">インプット</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">アウトプット</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(f(x)\)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-301">
<p>このアウトプットがY軸に対応する <code>y</code> の値となるような方程式なんですよ！とやっぱり宣言したい場合は、</p>
</div>
<div class="paragraph data-line-303">
<p>\(y = f(x)\)</p>
</div>
<div class="paragraph data-line-305">
<p>と、あらためて別途追加で書けば良いことなので辻褄もあうでしょう。</p>
</div>
<div class="imageblock data-line-307">
<div class="content">
<img src="./img/2-7-2020-13-21-13-PM.png" alt="2 7 2020 13 21 13 PM">
</div>
</div>
<table class="tableblock frame-all grid-all data-line-311" style="width: 80%;">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">インプット</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">アウトプット</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(y\)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(f(x)\)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-1">
<h2 id="_集合と写像">4. 集合と写像</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="sect2 data-line-22">
<h3 id="_集合と写像_2">4.1. 集合と写像</h3>
<div class="paragraph data-line-24">
<p>関数は、<a href="https://ja.wikipedia.org/wiki/%E9%9B%86%E5%90%88">集合</a>の観点から描き直せます。</p>
</div>
<div class="imageblock data-line-27">
<div class="content">
<img src="./img/2-7-2020-13-30-13-PM.png" alt="2 7 2020 13 30 13 PM">
</div>
</div>
<div class="paragraph data-line-30">
<p>こういうのを<a href="https://ja.wikipedia.org/wiki/%E9%9B%86%E5%90%88%E8%AB%96">集合論</a>の用語では、<a href="https://ja.wikipedia.org/wiki/%E5%86%99%E5%83%8F">写像</a>と呼びますが、呼び方や眺め方、描き方が異なるだけで、関数と同じものです。</p>
</div>
<div class="paragraph data-line-34">
<p>日常会話で、</p>
</div>
<div class="paragraph data-line-36">
<p>「国の首都っていうのは必ず都市でしょ？」</p>
</div>
<div class="paragraph data-line-38">
<p>という「一般論」は集合論で写像</p>
</div>
<div class="paragraph data-line-40">
<p>首都：国→都市</p>
</div>
<div class="paragraph data-line-42">
<p>のことを言っています。</p>
</div>
<div class="paragraph data-line-44">
<p>「うーん、ちょっと待って！抽象的で何を言ってるのかわからない。」</p>
</div>
<div class="paragraph data-line-46">
<p>となるのはよくあることです。そのとき、</p>
</div>
<div class="paragraph data-line-48">
<p>「具体的に言うと、たとえば、<br>
<strong>イギリス</strong>という<strong>国</strong> <br>
の首都は→<br>
 <strong>ロンドン</strong>という<strong>都市</strong><br>
 に必ずなっているでしょ？」</p>
</div>
<div class="paragraph data-line-55">
<p>この「という〇〇」を「具体的に言うと、たとえば、」</p>
</div>
<div class="paragraph data-line-57">
<p>としたのは、〇〇という集合と写像のレベルで話をしていたものを、</p>
</div>
<div class="paragraph data-line-59">
<p>「具体的」な集合の要素にレベルを落とした、ということになります。</p>
</div>
<div class="paragraph data-line-63">
<p><a href="https://www.britannica.com/science/set-theory" class="bare">https://www.britannica.com/science/set-theory</a></p>
</div>
<div class="paragraph data-line-65">
<p><strong>Set theory</strong>, branch of mathematics that deals with the properties of well-defined collections of objects, which may or may not be of a mathematical nature, such as numbers or functions. The theory is less valuable in direct application to ordinary experience than as a basis for precise and adaptable terminology for the definition of complex and sophisticated mathematical concepts.</p>
</div>
<div class="paragraph data-line-67">
<p><strong>集合論</strong>、数学の一分野で、数や関数などの数学的性質を持つか否かにかかわらず、対象物のよく定義された集合の性質を扱う。この理論は、複雑で洗練された数学的概念を定義するための正確で適応性のある用語の基礎としての価値よりも、通常の経験への直接的な応用としての価値の方が低い。</p>
</div>
<div class="paragraph data-line-70">
<p><a href="https://www.britannica.com/science/mapping" class="bare">https://www.britannica.com/science/mapping</a></p>
</div>
<div class="paragraph data-line-72">
<p><strong>Mapping</strong>, any prescribed way of assigning to each object in one set a particular object in another (or the same) set. Mapping applies to any set: a collection of objects, such as all whole numbers, all the points on a line, or all those inside a circle. For example, “multiply by two” defines a mapping of the set of all whole numbers onto the set of even numbers. A rotation is a map of a plane or of all of space into itself. In mathematics, the words mapping, map, and transformation tend to be used interchangeably.</p>
</div>
<div class="paragraph data-line-74">
<p><strong>マッピング</strong>、あるセットの各オブジェクトに、別の（または同じ）セットの特定のオブジェクトを割り当てる任意の所定の方法。マッピングは、すべての集合に適用されます: すべての整数、線上のすべての点、または円内のすべての点などのオブジェクトの集合。例えば、"multiply by two "は、すべての整数の集合から偶数の集合へのマッピングを定義しています。回転とは、平面の写像、または空間のすべての写像をそれ自身に写すことです。数学では、写像、写像、変換という言葉は互換的に使われる傾向があります。</p>
</div>
<div class="paragraph data-line-77">
<p>英和関数（英和写像）の場合はもちろん、こうなります。</p>
</div>
<div class="imageblock data-line-79">
<div class="content">
<img src="./img/2-7-2020-13-31-46-PM.png" alt="2 7 2020 13 31 46 PM">
</div>
</div>
<div class="paragraph data-line-81">
<p>「サイコロの目が偶数か奇数か？」と振り分ける事も関数（写像）です。</p>
</div>
<div class="imageblock data-line-83">
<div class="content">
<img src="./img/2-7-2020-13-32-32-PM.png" alt="2 7 2020 13 32 32 PM">
</div>
</div>
<div class="imageblock data-line-85">
<div class="content">
<img src="./img/2-7-2020-13-35-58-PM.png" alt="2 7 2020 13 35 58 PM">
</div>
</div>
<div class="paragraph data-line-87">
<p>集合 \(X\) の各要素 \(x\) に<br>
集合 \(Y\) の1つの要素 \(y\) を対応させる規則を<br>
\(X\)から\(Y\)への写像と呼びます。</p>
</div>
</div>
<div class="sect2 data-line-92">
<h3 id="_関数と定義域domainと終域値域rangeと型type">4.2. 関数と定義域(domain)と終域値域(range)と型(type)</h3>
<div class="paragraph data-line-94">
<p>文字列　　　小文字→大文字</p>
</div>
<div class="paragraph data-line-97">
<p><strong>2つの物事の関係性(binary relation)を持っている</strong>アイテム、「必ず答えを返してくるやつ」ではあるのですが、見方を変えたために、より「ある集合から別の集合へ転写するやつ」という感じになっています。<br>
何が良いのかというと、構造が明確になり、より厳密な議論がしやすくなります。<br>
特に、国と都市の集合、あるいは、英語と日本語の集合という範囲が明確になっています。<br>
実は、冒頭から説明している関数でも、<a href="https://ja.wikipedia.org/wiki/%E5%AE%9A%E7%BE%A9%E5%9F%9F">定義域</a>(<a href="https://www.mathsisfun.com/sets/domain-range-codomain.htmlj">domain</a>)という話はセットで必ずあります。</p>
</div>
<div class="paragraph data-line-103">
<p>この一見、面倒くさい議論は実はかなり重要で、<strong>首都関数のインプットは必ず「国」である、と決め打ちしているのと同じ</strong>です。<br>
<strong>首都関数の定義域(domain)は「国」である。</strong><br>
関数はいつもこのように、数式でかつXY平面にプロットできるものとは限らないので、一般的にはこうやって集合の範囲として捉えたほうが概念的には自然ではるかにわかりやすくなります。<br>
ただし、数値の場合は、上記のようにXY軸にプロットしているほうが視覚的に明確になるメリットは言うまでもありません。</p>
</div>
<div class="paragraph data-line-109">
<p>y = 2x</p>
</div>
<div class="paragraph data-line-111">
<p>自然数　自然数
整数　　整数　　＞０</p>
</div>
<div class="paragraph data-line-114">
<p>実数　実数</p>
</div>
<div class="imageblock data-line-116">
<div class="content">
<img src="./img/0-10-2020-19-12-07-PM.png" alt="0 10 2020 19 12 07 PM">
</div>
</div>
<div class="imageblock data-line-118">
<div class="content">
<img src="./img/0-10-2020-19-13-09-PM.png" alt="0 10 2020 19 13 09 PM">
</div>
</div>
<div class="imageblock data-line-120">
<div class="content">
<img src="./img/0-10-2020-19-14-36-PM.png" alt="0 10 2020 19 14 36 PM">
</div>
</div>
<div class="imageblock data-line-123">
<div class="content">
<img src="./img/5-7-2020-07-51-25-AM.png" alt="5 7 2020 07 51 25 AM">
</div>
</div>
<div class="paragraph data-line-125">
<p><a href="https://www.mathsisfun.com/sets/domain-range-codomain.html" class="bare">https://www.mathsisfun.com/sets/domain-range-codomain.html</a></p>
</div>
<div class="imageblock data-line-127">
<div class="content">
<img src="./img/0-10-2020-16-13-22-PM.png" alt="0 10 2020 16 13 22 PM">
</div>
</div>
<div class="ulist data-line-129">
<ul>
<li class="data-line-129">
<p>写像(関数)  \(f\) の<strong>定義域/始域(domain)</strong>は \(X\)</p>
</li>
<li class="data-line-131">
<p>写像(関数) \(f\) の<strong>値域(range)</strong>は \(f(x)\)</p>
</li>
<li class="data-line-133">
<p>写像(関数) \(f\) の<strong>終域(codomain)</strong>は \(Y\)</p>
</li>
</ul>
</div>
<div class="paragraph data-line-135">
<p><a href="https://ja.wikipedia.org/wiki/%E5%AE%9A%E7%BE%A9%E5%9F%9F">定義域/始域(domain)</a></p>
</div>
<div class="listingblock data-line-139">
<div class="content">
<pre>数学における写像の定義域（ていぎいき、英: domain of definition）あるいは始域（しいき、英: domain; 域, 領域）とは、写像の値の定義される引数（「入力」）の取り得る値全体からなる集合である。</pre>
</div>
</div>
<div class="paragraph data-line-143">
<p><a href="https://ja.wikipedia.org/wiki/%E5%80%A4%E5%9F%9F">値域(range)</a></p>
</div>
<div class="listingblock data-line-147">
<div class="content">
<pre>数学、特に素朴集合論における写像の値域（ちいき、英: range）は、その写像の終域または像の何れかの意味で用いられる。</pre>
</div>
</div>
<div class="paragraph data-line-151">
<p><a href="https://ja.wikipedia.org/wiki/%E7%B5%82%E5%9F%9F">終域(codomain)</a></p>
</div>
<div class="listingblock data-line-155">
<div class="content">
<pre>数学において写像の終域（しゅういき、英: codomain; 余域）あるいは終集合（しゅうしゅうごう、英: target set）は、写像を f: X → Y と表すときの集合 Y、すなわち写像 f の出力する値がその中に属するべきという制約を定める集合をいう。終域の代わりに「値域」という語を用いる場合もあるが、値域は写像の像（出力される値すべてからなる集合、f: X → Y で言えば f(X)）の意味で用いることが多いので注意すべきである。</pre>
</div>
</div>
<div class="listingblock data-line-161">
<div class="content">
<pre>定義と注意
さて Bourbaki (1954) の意味で写像（函数）を定義するのであれば、終域は写像 f の一部として含まれる[1]。即ち、写像 f とは三つ組 (X, Y, F) であって F が直積集合 X × Y の函数的部分集合（すなわち函数関係）[2]かつ F に属する順序対の第一成分の成す集合（すなわち定義域）が X に一致するものをいう。このとき集合 F はこの写像のグラフと呼ばれる。また、x が写像 f の定義域 X の元を亙るとき、f(x) の形に書ける元全てからなる集合を f の値域と呼ぶ。一般に値域は終域の部分集合であって、従って一般には両者は一致しないことが起こり得る。一致する場合（すなわち全射）でないならば、終域に属する適当な元 y に対して、方程式 f(x) = y は解を持たない。

ブルバキはまた別な定義として、「写像」を単に函数的グラフそのものと定め、これはまた広く用いられている定義であるが、これには終域が定義として含まれない。例えば集合論（英語版）において、定義域 X が真の類であることを許す方が望ましいという場合には、三つ組 (X, Y, F) といったものは厳密な意味では存在しないため定義に用いるには不適当だが、グラフによる定義ならば自然である。ただ、文献によっては f: X → Y という見かけ上終域に言及する形で写像を導入していながら、その後は暗黙にこの終域を含めない定義を用いる場合もあるので注意が必要である。</pre>
</div>
</div>
<div class="paragraph data-line-173">
<p><a href="https://en.wikipedia.org/wiki/Binary_relation" class="bare">https://en.wikipedia.org/wiki/Binary_relation</a></p>
</div>
<div class="paragraph data-line-175">
<p><a href="https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E9%96%A2%E4%BF%82" class="bare">https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E9%96%A2%E4%BF%82</a></p>
</div>
<div class="imageblock data-line-180">
<div class="content">
<img src="./img/5-7-2020-09-09-13-AM.png" alt="5 7 2020 09 09 13 AM">
</div>
</div>
<div class="imageblock data-line-182">
<div class="content">
<img src="./img/5-7-2020-09-11-20-AM.png" alt="5 7 2020 09 11 20 AM">
</div>
</div>
<div class="imageblock data-line-184">
<div class="content">
<img src="./img/5-7-2020-09-26-03-AM.png" alt="5 7 2020 09 26 03 AM">
</div>
</div>
<div class="paragraph data-line-186">
<p><a href="https://www.mathsisfun.com/sets/function.html" class="bare">https://www.mathsisfun.com/sets/function.html</a></p>
</div>
<div class="paragraph data-line-188">
<p>ただし、Google検索結果のように、「複数URLのリスト」のアウトプットは One-to-many のNGケースではありません。</p>
</div>
<div class="paragraph data-line-190">
<p>many-to-one については、サイコロの目が偶数か奇数か？の関数で説明したとおりです。</p>
</div>
<div class="paragraph data-line-192">
<p>なんでこういう条件がある関数でなければならないのか？</p>
</div>
<div class="paragraph data-line-194">
<p>関数はもっと広い二項関係の一部（部分集合）。</p>
</div>
<div class="paragraph data-line-196">
<p>プログラミングは処理をする、計算をすすめていく、という明確な目的があるので、単なる二項関係よりも、より厳しい条件である関数が適している。</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1">
<h2 id="_関数の表記_2">5. 関数の表記</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="sect2 data-line-22">
<h3 id="_関数を定義するタイミングとそれ以外の操作のタイミングの２種類の表記がある">5.1. 関数を定義するタイミングと、それ以外の操作のタイミングの２種類の表記がある</h3>
<div class="paragraph data-line-24">
<p>数学では、</p>
</div>
<div class="ulist data-line-26">
<ul>
<li class="data-line-26">
<p>定義</p>
</li>
<li class="data-line-28">
<p>それ以外</p>
</li>
</ul>
</div>
<div class="paragraph data-line-30">
<p>の２種類の操作があります。</p>
</div>
<div class="paragraph data-line-32">
<p>プログラミングでは、定義とそれ以外の操作は、かなりはっきりと書式が区別されていてわかりやすいですが、数式の場合はあまりはっきりと区別されることがないので、関数の表記でも混乱しやすいです。</p>
</div>
<div class="paragraph data-line-34">
<p>関数が簡単な数式で表現できるケースで調べていきます。</p>
</div>
<div class="sect3 data-line-36">
<h4 id="_関数を定義するとき関数の宣言fx流派">5.1.1. 関数を定義するとき（関数の宣言）　f(x)流派</h4>
<div class="paragraph data-line-38">
<p>アウトプットが\(f(x)\)という表記で、2倍する関数を定義するときは、</p>
</div>
<div class="paragraph data-line-40">
<p>\(f(x) = 2x\)</p>
</div>
<div class="paragraph data-line-42">
<p>と表記されます。</p>
</div>
<div class="paragraph data-line-44">
<p>関数を定義するときのこの表記方法は、かなり一般的で、学校ではみんな習うわけですが、実はかなりトリッキーなので要注意です。</p>
</div>
<div class="olist arabic data-line-46">
<ol class="arabic">
<li class="data-line-46">
<p>今、関数に <code>f</code> という名前をつけた。今後も <code>f</code> という名前で参照される。だからこの <code>f</code> という文字には特段の意味がある。</p>
</li>
<li class="data-line-48">
<p>今、関数に <code>x</code> の数式で構造を与えた。<code>x</code> というのは、単に「インプット」という文字の置き換えに過ぎなかった。だからこの <code>x</code> という文字には特段の意味はない。</p>
</li>
</ol>
</div>
<div class="paragraph data-line-50">
<p>というように、2つの異なる動作を一緒くたにやっているのです。</p>
</div>
<div class="paragraph data-line-52">
<p><code>x</code> というのは、単に「インプット」という文字の置き換えに過ぎないので、別に <code>a</code> という文字でも良かったので</p>
</div>
<div class="paragraph data-line-54">
<p>\(f(a) = 2a\)</p>
</div>
<div class="paragraph data-line-56">
<p>こう書いても、全く同じ関数を定義している数式になります。</p>
</div>
<div class="paragraph data-line-58">
<p><code>f</code> という関数名でなく、２倍しているという関数の性格がわかりやすくするために、<code>double</code> という名前の関数を定義しましょう。</p>
</div>
<div class="paragraph data-line-60">
<p>\(double(x) = 2x\)</p>
</div>
<div class="paragraph data-line-62">
<p>あるいは</p>
</div>
<div class="paragraph data-line-64">
<p>\(double(a) = 2a\)</p>
</div>
<div class="paragraph data-line-66">
<p>というように、独自の名前の関数を定義することもできます。</p>
</div>
</div>
<div class="sect3 data-line-69">
<h4 id="_関数を使うときfx流派">5.1.2. 関数を使うとき　f(x)流派</h4>
<div class="paragraph data-line-71">
<p>インプット、あるいは <code>x</code> が <code>３</code> のとき、</p>
</div>
<div class="imageblock data-line-73">
<div class="content">
<img src="./img/2-7-2020-13-37-36-PM.png" alt="2 7 2020 13 37 36 PM">
</div>
</div>
<div class="paragraph data-line-75">
<p>\(f(3)\)</p>
</div>
<div class="paragraph data-line-78">
<p><code>double</code> という名前の関数を使います。</p>
</div>
<div class="imageblock data-line-80">
<div class="content">
<img src="./img/2-7-2020-13-40-16-PM.png" alt="2 7 2020 13 40 16 PM">
</div>
</div>
<div class="paragraph data-line-83">
<p>\(double(5)\)</p>
</div>
<div class="sect4 data-line-85">
<h5 id="_三角関数">三角関数</h5>
<div class="imageblock data-line-87">
<div class="content">
<img src="./img/2-7-2020-13-42-00-PM.png" alt="2 7 2020 13 42 00 PM">
</div>
</div>
</div>
</div>
<div class="sect3 data-line-90">
<h4 id="_関数を定義するとき関数の宣言アロー矢印流派">5.1.3. 関数を定義するとき（関数の宣言）　アロー（矢印）流派</h4>
<div class="paragraph data-line-92">
<p>\(f(x)\)ではない別の流派が存在します。</p>
</div>
<div class="paragraph data-line-94">
<p>関数を集合論の写像として扱う流派で、アロー（矢印）流派と呼ぶことにしましょう。</p>
</div>
<div class="imageblock data-line-96">
<div class="content">
<img src="./img/2-7-2020-13-35-58-PM.png" alt="2 7 2020 13 35 58 PM">
</div>
</div>
<div class="paragraph data-line-98">
<p>\(X\xrightarrow{f}Y \)</p>
</div>
<div class="paragraph data-line-100">
<p>または</p>
</div>
<div class="paragraph data-line-102">
<p>\(f : X → Y \)</p>
</div>
<div class="paragraph data-line-104">
<p>と表記します。</p>
</div>
<div class="paragraph data-line-106">
<p>\(X\xrightarrow{f}Y \)は写像のイメージそのものですね。
わかりやすくて美しく手書きでは良いのでしょうが、デジタルというか特にコードでは扱いづらい記法なので、\(f : X → Y \)のほうを積極的に使いたいです。</p>
</div>
<div class="paragraph data-line-109">
<p>関数が数学法則を利用しており、X集合とY集合の関係式が展開できるときは、</p>
</div>
<div class="imageblock data-line-111">
<div class="content">
<img src="./img/2-7-2020-13-46-41-PM.png" alt="2 7 2020 13 46 41 PM">
</div>
</div>
<div class="paragraph data-line-114">
<p>インプット <code>ｘ</code> あるいは集合論の用語で<br>
集合Xの各元 <code>x</code> で</p>
</div>
<div class="paragraph data-line-117">
<p>\(f : x → 2x \)</p>
</div>
<div class="paragraph data-line-119">
<p>\(double : x → 2x \)</p>
</div>
<div class="paragraph data-line-121">
<p>などと書けてしまうでしょう。</p>
</div>
</div>
<div class="sect3 data-line-124">
<h4 id="_関数を使うときアロー矢印流派">5.1.4. 関数を使うとき　アロー（矢印）流派</h4>
<div class="paragraph data-line-126">
<p>関数を使うときに、矢印（アロー）流派で表記するというのは、長らく、少なくとも主流としては存在していませんでした。</p>
</div>
<div class="paragraph data-line-128">
<p>関数を定義するときはアロー流派でも、関数を適用するときにアウトプットを表記するときには、(x)流派の表記を使うというのが多いです。</p>
</div>
<div class="paragraph data-line-130">
<p>たとえば、\(\sin(x)\) あるいは、()を省略した\(\sin x\)という表記が今後も一般的ではなくなることはかなり考えづらく、プログラミングの世界でも同様だと思います。</p>
</div>
<div class="paragraph data-line-132">
<p>しかし、最近プログラミングの世界では、<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Pipeline_operator">パイプライン演算子</a>という、関数を写像のイメージとして捉えやすい表記方法が台頭してきています。</p>
</div>
<div class="imageblock data-line-134">
<div class="content">
<img src="./img/2-7-2020-13-48-34-PM.png" alt="2 7 2020 13 48 34 PM">
</div>
</div>
<div class="imageblock data-line-136">
<div class="content">
<img src="./img/6-7-2020-21-36-55-PM.png" alt="6 7 2020 21 36 55 PM">
</div>
</div>
<table class="tableblock frame-all grid-all data-line-139" style="width: 80%;">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">インプット</th>
<th class="tableblock halign-center valign-top">アウトプット</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">xy</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(y\)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">f(x)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(f(x)\)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">パイプライン</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(x\)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>x |&gt; f</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-155">
<p>JavaScriptでは<a href="https://github.com/tc39/proposal-pipeline-operator">実験的に導入がはじまろうとしている段階</a>で、<a href="https://github.com/microsoft/TypeScript/pull/38305">TypeScript4.0でも同様です</a>。</p>
</div>
</div>
<div class="sect3 data-line-158">
<h4 id="_fx流派とアロー流派の関数表記の比較">5.1.5. f(x)流派とアロー流派の関数表記の比較</h4>
<div class="imageblock data-line-160">
<div class="content">
<img src="./img/6-7-2020-21-26-22-PM.png" alt="6 7 2020 21 26 22 PM">
</div>
</div>
<div class="paragraph data-line-162">
<p>関数の表記で、学校で最初に習ったり、プログラミングの世界でもこれまで一般的だったのは、f(x)流派ですが、実はこの表記は写像のイメージで捉えると、<code>x</code> と <code>f</code> の左右の位置が逆になってしまっています。<br>
そのせいで、また別におはなししますが、厄介な問題を引き起こすことになります。</p>
</div>
<div class="paragraph data-line-165">
<p>他方で、矢印を使ったアロー流派の関数定義の表記やパイプライン演算子では、<code>x</code> と <code>f</code> が写像のイメージそのままの位置なので、論理的にわかりやすく明確で、コードも整いやすくなります。</p>
</div>
<table class="tableblock frame-all grid-all data-line-168" style="width: 80%;">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">定義</th>
<th class="tableblock halign-center valign-top">適用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">f(x)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(f(x) = 2x\)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(f(5)\)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">アロー</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">\(f : x → 2x \)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>5 |&gt; f</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-180">
<p>定義のときに、関数への名前付け、関数の構造の定義という異なる作業を同時にやっているのは両者変わらないように見えます。</p>
</div>
<div class="paragraph data-line-182">
<p>しかしよく見ると、f(x)流派が、名前付けと構造定義の場所が＝の両辺で混じり合ってしまっているのに対して、アロー流派は、きっちり <code>:</code> で分離されています。</p>
</div>
<div class="paragraph data-line-184">
<p>実際、関数の構造定義</p>
</div>
<div class="paragraph data-line-186">
<p>\(x → 2x\)</p>
</div>
<div class="paragraph data-line-188">
<p>だけを取り出して構いません。(<a href="https://ja.wikipedia.org/wiki/%E7%84%A1%E5%90%8D%E9%96%A2%E6%95%B0">無名関数</a>)</p>
</div>
<div class="paragraph data-line-190">
<p>別に関数定義のときに同時に名前付けをしなければいけない、というルールは存在しないのです。あとからオプションで、 <code>f</code> にする、<code>double</code> と名前を与えても構わない、自由です。</p>
</div>
</div>
</div>
<div class="sect2 data-line-193">
<h3 id="_javascriptの関数">5.2. JavaScriptの関数</h3>
<div class="paragraph data-line-195">
<p>関数の定義でアロー流派の表記は、JavaScriptでは近年標準化(<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/ECMAScript_6_support_in_Mozilla">ES6</a>)されて、<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Functions/Arrow_functions">アロー関数</a>として実装されています。</p>
</div>
<div class="paragraph data-line-197">
<p>プログラミング界隈では、同じものを<a href="https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97">ラムダ式</a>と呼ぶことが多いです。</p>
</div>
<div class="paragraph data-line-199">
<p>とりあえずここでは手っ取り早くJavaScriptが駆動する、<a href="https://developers.google.com/web/tools/chrome-devtools?hl=ja">ChromeブラウザのDevTools</a>のConsoleタブで試してみましょう。</p>
</div>
<div class="imageblock data-line-201">
<div class="content">
<img src="./img/5-7-2020-19-54-05-PM.png" alt="5 7 2020 19 54 05 PM">
</div>
</div>
<div class="paragraph data-line-203">
<p>\(x → 2x\) は、</p>
</div>
<div class="imageblock data-line-205">
<div class="content">
<img src="./img/0-7-2020-12-18-02-PM.png" alt="0 7 2020 12 18 02 PM">
</div>
</div>
<div class="paragraph data-line-208">
<p>としてコードに書けます。ChromeDevToolsのConsoleでは、アロー関数（ラムダ式）がタイプされた時点で、<br>
<code>f</code><br>
と表示されました。なんらかの関数であると認識されたようです。</p>
</div>
<hr>
<div class="paragraph data-line-214">
<p>この関数に <code>5</code> をインプットしてみます。</p>
</div>
<div class="paragraph data-line-216">
<p>ここでは、\(f(x)\) の表記を使って、</p>
</div>
<div class="paragraph data-line-218">
<p>\((x → 2x)(5)\)</p>
</div>
<div class="imageblock data-line-220">
<div class="content">
<img src="./img/0-7-2020-12-19-37-PM.png" alt="0 7 2020 12 19 37 PM">
</div>
</div>
<hr>
<div class="paragraph data-line-224">
<p>\(f : x → 2x\) と(無名)関数に名前をつけるのであれば、</p>
</div>
<div class="imageblock data-line-226">
<div class="content">
<img src="./img/0-7-2020-12-20-59-PM.png" alt="0 7 2020 12 20 59 PM">
</div>
</div>
<hr>
<div class="paragraph data-line-228">
<p>そのまま、<code>f</code> 関数として置き換えて</p>
</div>
<div class="paragraph data-line-230">
<p>\(f(5)\)</p>
</div>
<div class="imageblock data-line-232">
<div class="content">
<img src="./img/5-7-2020-19-40-48-PM.png" alt="5 7 2020 19 40 48 PM">
</div>
</div>
<hr>
<div class="admonitionblock note data-line-238">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">パイプライン演算子</div>
<div class="paragraph data-line-239">
<p>f(x)流派でないほうのアロー流派のパイプライン演算子は？ということですが、2020年時点では、上述のとおり次期JavaScript(<a href="https://en.wikipedia.org/wiki/ECMAScript#ES.Next">ES.Next</a>)の提案段階であり、ChromeDevToolsではまだ動作しません。</p>
</div>
<div class="imageblock data-line-241">
<div class="content">
<img src="./img/0-7-2020-12-27-33-PM.png" alt="0 7 2020 12 27 33 PM">
</div>
</div>
<div class="paragraph data-line-243">
<p>しかし、TypeScirpt4.0以降では実験的に導入され使用可能なので、本書ではパイプライン演算子を積極的に活用していきます。</p>
</div>
<div class="imageblock data-line-245">
<div class="content">
<img src="./img/5-7-2020-21-16-07-PM.png" alt="5 7 2020 21 16 07 PM">
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1">
<h2 id="_高階関数">6. 高階関数</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="paragraph data-line-22">
<p>関数は多重構造になります。</p>
</div>
<div class="paragraph data-line-24">
<p>そして、配列とオブジェクト(連想配列)も関数のひとつです。</p>
</div>
<div class="sect2 data-line-27">
<h3 id="_配列とオブジェクト連想配列は関数として機能する">6.1. 配列とオブジェクト(連想配列)は関数として機能する</h3>
<div class="paragraph data-line-29">
<p>JavaScriptには配列とオブジェクト(連想配列)というデータ構造があります。</p>
</div>
<div class="paragraph data-line-31">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></p>
</div>
<div class="quoteblock data-line-33">
<blockquote>
<div class="paragraph data-line-1">
<p>JavaScript の Array オブジェクトは、配列を構築するためのグローバルオブジェクトで、配列とは複数の要素の集合を格納管理するリスト構造です。</p>
</div>
</blockquote>
</div>
<div class="paragraph data-line-35">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Working_with_Objects">オブジェクトとプロパティ</a></p>
</div>
<div class="quoteblock data-line-37">
<blockquote>
<div class="paragraph data-line-1">
<p>JavaScript オブジェクトのプロパティは、ブラケット (角括弧) 記述法でもアクセスすることができます (詳しくはプロパティのアクセサーを参照してください)。個々のプロパティが文字列値と関連付けられてアクセスできるため、オブジェクトは連想配列と呼ばれることがあります。</p>
</div>
</blockquote>
</div>
<div class="paragraph data-line-39">
<p>JavaScriptのオブジェクトは<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/JSON">JSON</a>として各種設定ファイルとしても広く用いられています。</p>
</div>
<div class="sect3 data-line-41">
<h4 id="_配列">6.1.1. 配列</h4>
<div class="paragraph data-line-43">
<p>今、JavaScriptの配列データをつかって、かんたんなデータベースを作成します。</p>
</div>
<div class="paragraph data-line-45">
<p>配列というデータ構造では、格納された値にアクセスするために、<code>0</code>,<code>1</code>,<code>2</code> といった、データの並び順に自動的に付与された自然数のインデックスを使います。</p>
</div>
<table class="tableblock frame-all grid-all data-line-49" style="width: 80%;">
<caption class="title">Table 1. fruit配列</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">インデックス</th>
<th class="tableblock halign-center valign-top">データ</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">🍎</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">🍌</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">🍊</p></td>
</tr>
</tbody>
</table>
<div class="listingblock data-line-64">
<div class="title">配列</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const fruit = ["Apple", "Banana", "Orange"];

    console.log(
      fruit[1]
    );</code></pre>
</div>
</div>
<div class="listingblock data-line-74">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">Banana</code></pre>
</div>
</div>
<div class="imageblock data-line-78">
<div class="content">
<img src="./img/2-7-2020-14-40-23-PM.png" alt="2 7 2020 14 40 23 PM">
</div>
</div>
<div class="paragraph data-line-81">
<p><strong>配列はインデックスと要素の対応で、写像を形成しているので関数です。</strong></p>
</div>
</div>
<div class="sect3 data-line-83">
<h4 id="_連想配列オブジェクト">6.1.2. 連想配列（オブジェクト）</h4>
<div class="paragraph data-line-85">
<p>配列のようにデータの並び順に自動的に付与された自然数のインデックスを使うのではなく、ユーザが文字列のキーを付与すれば、オブジェクト(連想配列)となります。</p>
</div>
<table class="tableblock frame-all grid-all data-line-89" style="width: 80%;">
<caption class="title">Table 2. 英和辞書</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">キー</th>
<th class="tableblock halign-center valign-top">データ</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">book</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">本</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">water</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">水</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">cat</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">猫</p></td>
</tr>
</tbody>
</table>
<div class="listingblock data-line-105">
<div class="title">オブジェクト（連想配列）</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const dictionary = {
      "book": "本",
      "water": "水",
      "cat": "猫",
    };
    console.log(
      dictionary["cat"]
    );</code></pre>
</div>
</div>
<div class="listingblock data-line-118">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">猫</code></pre>
</div>
</div>
<div class="imageblock data-line-122">
<div class="content">
<img src="./img/2-7-2020-14-41-19-PM.png" alt="2 7 2020 14 41 19 PM">
</div>
</div>
<div class="paragraph data-line-125">
<p><strong>オブジェクトは連想配列とも呼ばれており、辞書のように機能していて、これも写像を形成しているので関数です。</strong></p>
</div>
<div class="imageblock data-line-128">
<div class="content">
<img src="./img/2-7-2020-13-09-51-PM.png" alt="2 7 2020 13 09 51 PM">
</div>
</div>
<div class="paragraph data-line-130">
<p>特に、各要素にアクセスする際の、</p>
</div>
<div class="listingblock data-line-133">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  fruit[1]
  dictionary["cat"]</code></pre>
</div>
</div>
<div class="paragraph data-line-137">
<p>は、</p>
</div>
<div class="imageblock data-line-139">
<div class="content">
<img src="./img/6-7-2020-21-26-22-PM.png" alt="6 7 2020 21 26 22 PM">
</div>
</div>
<div class="paragraph data-line-141">
<p>の表記と酷似しており <code>[]</code> と <code>()</code> が異なるだけです。</p>
</div>
</div>
</div>
<div class="sect2 data-line-144">
<h3 id="_配列とオブジェクトの多重構造">6.2. 配列とオブジェクトの多重構造</h3>
<div class="paragraph data-line-146">
<p>配列は別の配列に入れ子にすることで、多重構造を形成できます。</p>
</div>
<table class="tableblock frame-all grid-all data-line-150" style="width: 80%;">
<caption class="title">Table 3. 食べ物（food）の多重配列</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">フルーツ</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">[🍎, 🍌, 🍊]</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">肉</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">[🥩, 🥓, 🍗]</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">スイーツ</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">[🍰, 🍫, 🍧]</p></td>
</tr>
</tbody>
</table>
<div class="listingblock data-line-158">
<div class="title">配列の合成</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const fruit = ["Apple", "Banana", "Orange"];
    const meat = ["beef", "bacon", "chicken"];
    const sweet = ["cake", "choco", "ice"];

    const food = [fruit, meat, sweet];

    console.log(
      food[0]  // ["Apple", "Banana", "Orange"]
    );
    console.log(
      food[1]  // ["beef", "bacon", "chicken"]
    );
    console.log(
      food[2]  // ["cake", "choco", "ice"]
    );
    console.log(
      food[2][0]  // "cake"
    );</code></pre>
</div>
</div>
<div class="listingblock data-line-181">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">["Apple", "Banana", "Orange"]
["beef", "bacon", "chiken"]
["cake", "choco", "ice"]
"cake"</code></pre>
</div>
</div>
<div class="imageblock data-line-188">
<div class="content">
<img src="./img/2-7-2020-14-48-30-PM.png" alt="2 7 2020 14 48 30 PM">
</div>
</div>
<div class="listingblock data-line-192">
<div class="title">配列の合成</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const a = [1, 2];

    const b = [a, a, a];

    console.log(
      b  //  [ [ 1, 2 ], [ 1, 2 ], [ 1, 2 ] ]
    );

    console.log(
      b[0] //  [ 1, 2 ]
    );

    console.log(
      b[0][1] //2
    );</code></pre>
</div>
</div>
<div class="listingblock data-line-213">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">[ [ 1, 2 ], [ 1, 2 ], [ 1, 2 ] ]
[ 1, 2 ]
2</code></pre>
</div>
</div>
<div class="imageblock data-line-219">
<div class="content">
<img src="./img/2-7-2020-15-00-26-PM.png" alt="2 7 2020 15 00 26 PM">
</div>
</div>
<div class="imageblock data-line-221">
<div class="content">
<img src="./img/2-7-2020-15-01-19-PM.png" alt="2 7 2020 15 01 19 PM">
</div>
</div>
<div class="paragraph data-line-223">
<p><code>a</code> が一次元配列にたいして、<code>b</code> は二次元配列、あるいは多次元配列と呼ばれます。</p>
</div>
<div class="paragraph data-line-225">
<p>そして、配列は関数なので、関数の多重構造を形成しています。</p>
</div>
<div class="paragraph data-line-227">
<p>このように、多重構造となっている関数を<a href="https://ja.wikipedia.org/wiki/%E9%AB%98%E9%9A%8E%E9%96%A2%E6%95%B0">高階関数</a>(<a href="https://en.wikipedia.org/wiki/Higher-order_function">Higher-order function</a>)と呼びます。</p>
</div>
<div class="paragraph data-line-229">
<p>もちろん、多重構造になっている配列、オブジェクトも高階関数です。</p>
</div>
<div class="sect3 data-line-232">
<h4 id="_多重構造の配列の要素へのアクセス">6.2.1. 多重構造の配列の要素へのアクセス</h4>
<div class="paragraph data-line-233">
<p><code>b[0]</code> = <code>[1, 2]</code> = <code>a</code> なので</p>
</div>
<div class="paragraph data-line-235">
<p><code>a[1]</code> = <code>(b[0])[1]</code> = <code>b[0][1]</code>  = <code>2</code></p>
</div>
</div>
<div class="sect3 data-line-237">
<h4 id="_多重構造の関数への多重インプット">6.2.2. 多重構造の関数への多重インプット</h4>
<div class="paragraph data-line-239">
<p><code>f(0)</code>　= <code>g</code> としたとき</p>
</div>
<div class="paragraph data-line-241">
<p><code>g(1)</code> = <code>(f(0))(1)</code> = <code>f(0)(1)</code></p>
</div>
<div class="paragraph data-line-243">
<p>配列、オブジェクト（連想配列）も関数も、多重構造の表記の仕方はカッコの種類が異なるだけで同じになります。</p>
</div>
<div class="admonitionblock note data-line-248">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">カッコを外す</div>
<div class="paragraph data-line-249">
<p>JavaScriptをふくむ他の多くのプログラミング言語では、<code>()</code> が<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">演算子の優先順位</a>としてもっとも高くなっています。</p>
</div>
<div class="paragraph data-line-251">
<p>コードが複雑になるにつれ、論理的にひとまとまりの部分は、積極的に <code>()</code> でくくることで、プログラマはJavaScriptエンジンがコードを想定していない解釈をしてしまうことから防ぐことがあります。</p>
</div>
<div class="paragraph data-line-253">
<p>配列やオブジェクトで、</p>
</div>
<div class="paragraph data-line-255">
<p><code>a</code> = <code>b[0]</code> のとき<br>
<code>a[1]</code> の意味を確定するために<br>
<code>(b[0])[1]</code> <br>
とカッコでくくりたくなるかもしれませんが、不要で<br>
<code>b[0][1]</code> のほうが簡潔でスマートな記法となります。</p>
</div>
<div class="paragraph data-line-261">
<p>関数でも同じように、</p>
</div>
<div class="paragraph data-line-263">
<p><code>(f(0))(1)</code> ではなく<br>
<code>f(0)(1)</code> としたほうが簡潔でスマートな記法です。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-268">
<p>f(x)表記は合成関数のとき入れ子になる、わかりにくい。
パイプラインオペレータは合成関数を表現するとき、イメージそのままなのでわかりやすくなる。</p>
</div>
<div class="paragraph data-line-271">
<p>f(x)表記は高階関数が適用されるとき入れ子にならない、わかりやすくなる。
パイプラインオペレータは高階関数が適用されるとき入れ子になりわかりにくくなる。</p>
</div>
</div>
</div>
<div class="sect2 data-line-275">
<h3 id="_関数は複数のインプットを処理できる">6.3. 関数は複数のインプットを処理できる</h3>
<div class="sect3 data-line-277">
<h4 id="_天気予報という関数">6.3.1. 天気予報という関数</h4>
<div class="listingblock data-line-281">
<div class="title">天気予報データ</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const weekly = {
      "sapporo": ["☂", "☀", "☀", "☂", "☀", "☀", "☀"],
      "tokyo__": ["☂", "☀", "☀", "☂", "☀", "☀", "☀"],
      "nagoya_": ["☂", "☀", "☀", "☂", "☀", "☀", "☀"],
      "osaka__": ["☂", "☀", "☀", "☂", "☂", "☀", "☀"],
      "fukuoka": ["☂", "☂", "☂", "☂", "☂", "☀", "☀"],
      "naha___": ["☂", "☂", "☂", "☂", "☀", "☀", "☀"]
    };</code></pre>
</div>
</div>
<div class="paragraph data-line-292">
<p><strong>都市</strong>がキーで、<strong>週間天気予報</strong>の配列（関数）がプロパティのオブジェクト（連想配列）になっています。</p>
</div>
<div class="paragraph data-line-294">
<p><code>weekly["sapporo"]</code> とすれば、<br>
<code>["☂", "☀", "☀", "☂", "☀", "☀", "☀"]</code>
と週間予報にアクセスできる構造の配列です。</p>
</div>
<div class="paragraph data-line-298">
<p>さらに、</p>
</div>
<div class="paragraph data-line-300">
<p><code>["☂", "☀", "☀", "☂", "☀", "☀", "☀"][0]</code> とすれば、<br>
「今日」の札幌の天気は <code>☂</code></p>
</div>
<div class="paragraph data-line-303">
<p><code>["☂", "☀", "☀", "☂", "☀", "☀", "☀"][1]</code> とすれば、<br>
「明日」の札幌の天気は <code>☀</code></p>
</div>
<div class="paragraph data-line-306">
<p>となります。従って一気に表記するならば、</p>
</div>
<div class="paragraph data-line-308">
<p><code>weekly["sapporo"][1]</code> =  <code>☀</code> と</p>
</div>
<div class="paragraph data-line-310">
<p>札幌の明日の天気にアクセスできます。</p>
</div>
<div class="paragraph data-line-312">
<p>これは<a href="https://ja.wikipedia.org/wiki/%E9%AB%98%E9%9A%8E%E9%96%A2%E6%95%B0">高階関数</a>(<a href="https://en.wikipedia.org/wiki/Higher-order_function">Higher-order function</a>)です。</p>
</div>
</div>
</div>
<div class="sect2 data-line-315">
<h3 id="_複数のインプットをとる関数へのおきかえ">6.4. 複数のインプットをとる関数へのおきかえ</h3>
<div class="paragraph data-line-317">
<p>配列、オブジェクトは関数なので、それ自体で完結しており、それ以上余計なことをしないほうがコードがスッキリすることが多いですが、アロー関数（ラムダ式）に置き換えることで便利になることがあります。</p>
</div>
<div class="paragraph data-line-319">
<p>まずは、あんまり意味のない置き換えです。</p>
</div>
<div class="listingblock data-line-324">
<div class="title">天気予報関数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const forecast =
    　　   (city, date) =&gt; weekly[city][date];</code></pre>
</div>
</div>
<div class="paragraph data-line-329">
<p><strong>都市</strong>(<code>city</code>)と<strong>日付</strong>(<code>date</code>)という2つのインプット<br>
アウトプットは、<code>"☀"</code> <code>"☂"</code> のいずれかとなる関数です。</p>
</div>
<div class="imageblock data-line-332">
<div class="content">
<img src="./img/2-7-2020-15-03-54-PM.png" alt="2 7 2020 15 03 54 PM">
</div>
</div>
<div class="imageblock data-line-334">
<div class="content">
<img src="./img/2-7-2020-15-05-51-PM.png" alt="2 7 2020 15 05 51 PM">
</div>
</div>
<div class="listingblock data-line-338">
<div class="title">東京の明日の天気</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    console.log(
      forecast("tokyo__", 1)  <i class="conum" data-value="1"></i><b>(1)</b>
    ); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-344">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong>都市</strong>(<code>city</code>)は <code>"tokyo__"</code> で東京、<strong>日付</strong>(<code>date</code>)は <code>1</code> で明日</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>☀</td>
</tr>
</table>
</div>
<div class="paragraph data-line-346">
<p><code>forecast(city, date)</code> でアクセスできるのですが、<strong>そもそも</strong>
<code>weekly[city][date]</code> <strong>でアクセスできていた</strong>ので、単に表記の置き換え、にしかなっていません。</p>
</div>
<div class="paragraph data-line-349">
<p>これは意味がなく、良くありません。</p>
</div>
</div>
<div class="sect2 data-line-351">
<h3 id="_アウトプットが関数である高階関数">6.5. アウトプットが関数、である高階関数</h3>
<div class="paragraph data-line-353">
<p><code>forecast(city, date)</code> はその日の天気にしかアクセスできませんが、<br>
<code>weekly[city][date]</code> はその日の天気だけではなく、<br>
<code>weekly[city]</code> で週間天気予報にアクセスできました。</p>
</div>
<div class="paragraph data-line-357">
<p>もともとそういう連想配列のデータ構造です。</p>
</div>
<div class="imageblock data-line-359">
<div class="content">
<img src="./img/2-7-2020-15-07-57-PM.png" alt="2 7 2020 15 07 57 PM">
</div>
</div>
<div class="listingblock data-line-363">
<div class="title">東京の週間予報関数をアウトプット</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    console.log(
    　weekly["tokyo__"]
    );</code></pre>
</div>
</div>
<div class="listingblock data-line-371">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">["☂", "☀", "☀", "☂", "☀", "☀", "☀"]</code></pre>
</div>
</div>
<div class="imageblock data-line-375">
<div class="content">
<img src="./img/2-7-2020-15-09-18-PM.png" alt="2 7 2020 15 09 18 PM">
</div>
</div>
<div class="paragraph data-line-377">
<p>アロー関数を用意するのであれば、ある都市の週間予報（関数）のほうが良いです。</p>
</div>
<div class="listingblock data-line-381">
<div class="title">東京の週間予報関数を日付インプットのアロー関数にしておく</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const weekyTokyo =
           date =&gt; weekly["tokyo__"][date];</code></pre>
</div>
</div>
<div class="listingblock data-line-388">
<div class="title">東京の週間予報関数に日付をインプットして、天気予報をアウトプット</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    console.log(
      weekyTokyo(1)
    );</code></pre>
</div>
</div>
<div class="listingblock data-line-396">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">☀</code></pre>
</div>
</div>
<div class="paragraph data-line-400">
<p>imazge::2-7-2020-15-10-32-PM.png[]</p>
</div>
<div class="paragraph data-line-402">
<p>任意の都市の週間予報（関数）を得られる <code>forecast</code> 関数はこうなります。</p>
</div>
<div class="listingblock data-line-405">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const forecast =
      　　　city =&gt; (date =&gt; weekly[city][date]);</code></pre>
</div>
</div>
<div class="paragraph data-line-410">
<p>note!!!
    //高階関数で、入れ子の中の引数が使えるクロージャという実装</p>
</div>
<div class="literalblock data-line-413">
<div class="content">
<pre>    こういう高階関数が自然に表現できるように実装されているだけで、
    一部、覚えておくべきテクニックのように喧伝されることがありますが、
    関数型プログラミングの枠組みではi気にする必要はありません。
note!!!</pre>
</div>
</div>
<div class="imageblock data-line-418">
<div class="content">
<img src="./img/2-7-2020-15-29-47-PM.png" alt="2 7 2020 15 29 47 PM">
</div>
</div>
<div class="paragraph data-line-420">
<p>こうしておけば、</p>
</div>
<div class="listingblock data-line-423">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const weekyTokyo = forecast("tokyo__");
    const weekyFukuoka = forecast("fukuoka");</code></pre>
</div>
</div>
<div class="paragraph data-line-428">
<p>と <code>forecast</code> 関数から、任意の都市の週間予報（関数）を得られるようになります。</p>
</div>
<div class="paragraph data-line-430">
<p>明日の天気予報を得るには、</p>
</div>
<div class="listingblock data-line-433">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    console.log(
      weekyTokyo(1)
    );
    console.log(
      weekyFukuoka(1)
    );</code></pre>
</div>
</div>
<div class="listingblock data-line-444">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">☀
☂</code></pre>
</div>
</div>
<div class="paragraph data-line-449">
<p>となります。</p>
</div>
<div class="paragraph data-line-451">
<p>しかし、よくよく考えると、</p>
</div>
<div class="listingblock data-line-454">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    console.log(
      forecast("tokyo__")(1)
    );
    console.log(
      forecast("fukuoka")(1)
    );</code></pre>
</div>
</div>
<div class="listingblock data-line-465">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">☀
☂</code></pre>
</div>
</div>
<div class="paragraph data-line-470">
<p>とすればいいだけのことですし、見やすさも同じ、余計な関数を定義しなくて済むので、こちらのほうが良いです。</p>
</div>
<div class="paragraph data-line-472">
<p>つまり、</p>
</div>
<div class="listingblock data-line-475">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const forecast =
      　　　city =&gt; (date =&gt; weekly[city][date]);</code></pre>
</div>
</div>
<div class="paragraph data-line-479">
<p>として定義した場合、<br>
<code>forecast(city)</code> で週間天気予報にアクセスできる、<br>
<code>forecast(city)(date)</code> でさらに特定に日時の天気予報にアクセスできる。</p>
</div>
<div class="admonitionblock note data-line-486">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">比較してみよう</div>
<div class="listingblock data-line-488">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    {
   　　const forecast =
    　　   (city, date) =&gt; weekly[city][date];　<i class="conum" data-value="1"></i><b>(1)</b>

      console.log(
        forecast("tokyo__", 1)
      );
    }
    {
      const forecast =
      　　　city =&gt; date =&gt; weekly[city][date]; <i class="conum" data-value="2"></i><b>(2)</b>

      console.log(
        forecast("tokyo__")(1)
      );
    }</code></pre>
</div>
</div>
<div class="colist arabic data-line-507">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>2つのインプットの関数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ラムダ式の連鎖で書き直されている(<a href="https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%AA%E3%83%BC%E5%8C%96">カリー化</a>)。アウトプットの関数をかこむ()は外している</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-510">
<p>これは配列（オブジェクト）をそのまま操作していたとき、<br>
<code>weekly[city]</code> で週間天気予報にアクセスできる、<br>
<code>weekly[city][date]</code> でさらに特定に日時の天気予報にアクセスできる。</p>
</div>
<div class="paragraph data-line-514">
<p>という構図とまったく同じになっています。</p>
</div>
<div class="paragraph data-line-516">
<p>あれ？それならば、これも一周まわって、あんまり意味のない単なる表記の置き換えにすぎなかったのではないか？やっぱり配列をそのまま使っても良かったのでは？？と疑念が出てきますが、実はまだまだとんでもなく大きなメリットが隠れています。</p>
</div>
<div class="paragraph data-line-518">
<p>まず、余計なカッコを外します。</p>
</div>
<div class="listingblock data-line-521">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const forecast =
      　　　city =&gt; date =&gt; weekly[city][date];</code></pre>
</div>
</div>
<div class="paragraph data-line-526">
<p>次になんとなく、インプットの <code>city</code> と <code>date</code> の位置を交換してみます。</p>
</div>
<div class="listingblock data-line-530">
<div class="title">city date の位置を入れ替える</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const forecast =
      　　　date =&gt; city =&gt; weekly[city][date];</code></pre>
</div>
</div>
<div class="paragraph data-line-535">
<p>これで関数の意味が変わりました。</p>
</div>
<div class="paragraph data-line-537">
<p>わかりやすいように再び <code>()</code> をつけると、</p>
</div>
<div class="listingblock data-line-539">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const forecast =
      　　　date =&gt; (city =&gt; weekly[city][date]);</code></pre>
</div>
</div>
<div class="paragraph data-line-544">
<p><strong>日時をインプットして「各地の予報」関数をアウトプットする関数になっています。</strong></p>
</div>
<div class="imageblock data-line-546">
<div class="content">
<img src="./img/2-7-2020-15-31-24-PM.png" alt="2 7 2020 15 31 24 PM">
</div>
</div>
<div class="imageblock data-line-548">
<div class="content">
<img src="./img/2-7-2020-15-32-57-PM.png" alt="2 7 2020 15 32 57 PM">
</div>
</div>
<div class="imageblock data-line-550">
<div class="content">
<img src="./img/2-7-2020-15-33-51-PM.png" alt="2 7 2020 15 33 51 PM">
</div>
</div>
<div class="imageblock data-line-552">
<div class="content">
<img src="./img/2-7-2020-15-35-00-PM.png" alt="2 7 2020 15 35 00 PM">
</div>
</div>
<div class="listingblock data-line-555">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">      const forecast = date =&gt; city =&gt; weekly[city][date]; <i class="conum" data-value="1"></i><b>(1)</b>

      const tommorow = forecast(1); <i class="conum" data-value="2"></i><b>(2)</b>

      console.log(
        tommorow("tokyo__")
      ); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-566">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>日時をインプットして「各地の予報」関数をアウトプットする関数を定義</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>各地の予報（明日）の関数を定義</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>☀</td>
</tr>
</table>
</div>
<div class="paragraph data-line-568">
<p>配列 <code>weekly[city][date]</code> そのままではこの芸当は不可能です。</p>
</div>
<div class="paragraph data-line-570">
<p><code>weekly[city]</code> は連想配列のデータ構造そのままなのでアクセスできるのですが、<br>
<code>weekly[date]</code> にはアクセスできません。</p>
</div>
<div class="paragraph data-line-573">
<p>アクセスできるようになんらかの繰り返し処理をつかって配列をトレースしたり、あるいはいちいち面倒なので諦めて、なんらかのデータベースフレームワークを使うしかないでしょう。</p>
</div>
<div class="paragraph data-line-575">
<p>ところが、アロー表記（ラムダ式）を使った関数では、インプットの位置をちょっと入れ替えるだけで、かんたんに実現可能です。</p>
</div>
</div>
<div class="sect2 data-line-578">
<h3 id="_関数のカリー化と部分適用">6.6. 関数のカリー化と部分適用</h3>
<div class="paragraph data-line-580">
<p>このように、都市と日時という複数のインプットがある天気予報関数に、<br>
都市をインプットすれば、週間予報関数<br>
日時をインプットすれば、各地の予報関数</p>
</div>
<div class="paragraph data-line-584">
<p>と、次のステップでまた有効に活用できる関数を得られるような方法、インプットの一部分だけを関数に適用するようなコンセプトを関数の部分適用(partial application)と呼びます。</p>
</div>
<div class="paragraph data-line-586">
<p>ここで説明したとおり、複数インプットの関数をカリー化することで部分適用を実現可能ですが、f(a,b)のままで、言語レベルで自動的に内部的にカリー化して、部分適用したら関数返ってくるみたいな実装もあります。</p>
</div>
<div class="paragraph data-line-588">
<p><a href="https://github.com/tc39/proposal-partial-application" class="bare">https://github.com/tc39/proposal-partial-application</a></p>
</div>
<div class="listingblock data-line-592">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">f(x, ?)           // partial application from left
f(?, x)           // partial application from right
f(?, x, ?)        // partial application for any arg</code></pre>
</div>
</div>
<div class="paragraph data-line-598">
<p>JavaScriptの言語レベルで部分適用が利用できるようになると、</p>
</div>
<div class="listingblock data-line-602">
<div class="title">天気予報関数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const forecast =
    　　   (city, date) =&gt; weekly[city][date];</code></pre>
</div>
</div>
<div class="paragraph data-line-607">
<p>と定義してしまっても、</p>
</div>
<div class="listingblock data-line-610">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">forecast(?, 1)</code></pre>
</div>
</div>
<div class="paragraph data-line-614">
<p>というように、配列やオブジェクトそのままのアクセス手段では手が届かなかった関数の部分適用が、この定義の仕方の関数でも利用できるので「意味がない置き換え」とはならないでしょう。</p>
</div>
<div class="paragraph data-line-616">
<p>しかし、どうせたかだか機械的に</p>
</div>
<div class="listingblock data-line-620">
<div class="title">天気予報関数</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    const forecast =
    　　    city =&gt; date =&gt; weekly[city][date];</code></pre>
</div>
</div>
<div class="paragraph data-line-625">
<p>などと定義時にカリー化しておればよいことなので、関数の基本に忠実に、複数インプットの関数はなるだけカリー化して扱うという習慣を身に着けておいたほうがスマートです。</p>
</div>
<div class="listingblock data-line-628">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  {
    const times = (a, b) =&gt; a * b;

    console.log(
      times(2, 7)
    );
  }
  {
    const times = a =&gt; b =&gt; a * b;

    console.log(
      times(2)(7)
    );
  }</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-645">
<h3 id="_インプットが関数である高階関数">6.7. インプットが関数、である高階関数</h3>
<div class="paragraph data-line-647">
<p>ここまでは、アウトプットが関数、である高階関数について調べましたが、逆にインプットが関数となっている高階関数はあるでしょうか？</p>
</div>
<div class="paragraph data-line-649">
<p>あります。たとえば、こんな感じの関数です。</p>
</div>
<div class="imageblock data-line-651">
<div class="content">
<img src="./img/5-7-2020-08-10-50-AM.png" alt="5 7 2020 08 10 50 AM">
</div>
</div>
<div class="paragraph data-line-653">
<p>「天気予報」というデータベース＝関数はご存知の通りリアルタイムに更新されていますから、最新のデータベースを使いたいケースは多いでしょう。</p>
</div>
<div class="paragraph data-line-655">
<p>このようなとき、何でも構わないですが、たとえば「明日の東京の天気」関数に最新の「天気予報」をインプットしてやれば良いです。</p>
</div>
</div>
<div class="sect2 data-line-657">
<h3 id="_インプットが関数アウトプットが関数である高階関数">6.8. インプットが関数、アウトプットが関数、である高階関数</h3>
<div class="paragraph data-line-659">
<p>インプットもアウトプットも両方が関数になっている関数は、たとえば、こうなります。</p>
</div>
<div class="sect3 data-line-661">
<h4 id="_天気予報というデータベース関数がインプット各地の天気予報というデータベース関数がアウトプット">6.8.1. 天気予報というデータベース（関数）がインプット、各地の天気予報というデータベース（関数）がアウトプット</h4>
<div class="imageblock data-line-663">
<div class="content">
<img src="./img/5-7-2020-08-42-49-AM.png" alt="5 7 2020 08 42 49 AM">
</div>
</div>
</div>
<div class="sect3 data-line-667">
<h4 id="_簡易データベース">6.8.2. 簡易データベース</h4>

</div>
<div class="sect3 data-line-671">
<h4 id="_カリー化curryアンカリー化uncurryする関数">6.8.3. カリー化(curry)、アンカリー化(uncurry)する関数</h4>
<div class="paragraph data-line-673">
<p>カリー化、アンカリー化、と相互に変換する関数を定義できます。</p>
</div>
<div class="sect4 data-line-675">
<h5 id="_カリー化curry">カリー化(curry)</h5>
<div class="paragraph data-line-677">
<p>Before:カリー化されていない関数（uncurried funciton）<br>
After: カリー化された関数（curried function）<br>
という関数</p>
</div>
<div class="listingblock data-line-682">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  const curry =
    f =&gt;                 //before (uncurried)
      a =&gt; b =&gt; f(a, b); //after  (curried)</code></pre>
</div>
</div>
</div>
<div class="sect4 data-line-688">
<h5 id="_アンカリー化uncurry">アンカリー化(uncurry)</h5>
<div class="paragraph data-line-690">
<p>Before:カリー化された関数（curried function）<br>
After: カリー化されていない関数（uncurried funciton）<br>
という関数</p>
</div>
<div class="listingblock data-line-695">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  const uncurry =
    f =&gt;                 //before (curried)
      (a, b) =&gt; f(a)(b); //after  (uncurried)</code></pre>
</div>
</div>
<div class="paragraph data-line-701">
<p>これらはパラメータが2個の関数を扱うもっともシンプルなケースですが、3個の場合でもabcと増えるだけで同じようになります。</p>
</div>
<div class="paragraph data-line-703">
<p>パラメータの個数が決まっていない、というよりどんなパラメータ数の関数でも扱えるようにするには、もうちょっと工夫が必要で複雑になってきますが、オフトピックなのでここでは踏み込みません。</p>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-706">
<h3 id="_関数の構成はかんたんで自由自在">6.9. 関数の構成はかんたんで自由自在</h3>
<div class="paragraph data-line-708">
<p>このように少ない材料からでも、用途や目的に応じていくらでも関数を自由自在に組み立てることができます。</p>
</div>
<div class="admonitionblock note data-line-714">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">合成関数（関数の合成）と高階関数を比較してみよう</div>
<div class="paragraph data-line-716">
<p>pic</p>
</div>
<div class="paragraph data-line-719">
<p>pic</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock data-line-727">
<div class="title">Console</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  const identity = a =&gt; a;

  const right = a =&gt; identity;
  {
    const right = a =&gt; b =&gt; b;
  }

  const log = msg =&gt; right
    (console.log(msg))
    (msg);</code></pre>
</div>
</div>
<div class="paragraph data-line-740">
<p>right は identity関数を返す高階関数</p>
</div>
<div class="paragraph data-line-742">
<p>console.logはアウトプットがundefinedなので使いにくい、</p>
</div>
<div class="paragraph data-line-744">
<p>log という値を返す関数
基本、msg &#8594; msg というidentityになっているが、
副作用として、その値をconsole.logでコンソールに出力する。
console.log(msg)の返り値のundefinedは捨ててしまう。</p>
</div>
<div class="paragraph data-line-749">
<p>identityなので他に影響を及ぼすことなく、素通りする。</p>
</div>
<div class="paragraph data-line-751">
<p>デバッグに使える。</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1">
<h2 id="_演算子">7. 演算子</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="paragraph data-line-22">
<p>演算子とは関数のf(x) 写像ラムダ式以外の
第３の表記法</p>
</div>
<div class="paragraph data-line-25">
<p><a href="https://www.britannica.com/topic/operator" class="bare">https://www.britannica.com/topic/operator</a></p>
</div>
<div class="listingblock data-line-29">
<div class="content">
<pre>Operator, in mathematics, any symbol that indicates an operation to be performed. Examples are Square root of√x (which indicates the square root is to be taken) and d/dx (which indicates differentiation with respect to x is to be performed). An operator may be regarded as a function, transformation, or map, in the sense that it associates or “maps” elements from one set to elements from another set.

演算子、数学では、実行されるべき演算を示す任意の記号。例としては、√xの平方根（平方根を取ることを示す）やd/dx（xに対する微分が実行されることを示す）などがある。演算子は、ある集合の要素を別の集合の要素に関連付ける、または「マップ」するという意味で、関数、変換、または写像とみなされることがあります。</pre>
</div>
</div>
<div class="paragraph data-line-40">
<p>一項演算と二項演算 写像 f : X −→ X は, 各 x ∈ X に対して何らかの演算
を施して f(x) ∈ X を与えるという機能を持つので, この観点から一項演算と
も呼ばれる. たとえば, 実数の符号反転 x 7→ −x, 複素共役 z 7→ z¯, 命題の否定
P 7→ ¬P, 補集合 A 7→ Ac などは一項演算である.
同様に, 写像 f : X × X −→ X は, 順序対 (x, y) ∈ X × X に対して何らかの
演算を施して f(x, y) ∈ X を与えるという機能を強調して, 二項演算と呼ばれ
ることがある. たとえば, 実数の和 (x, y) 7→ x + y, 行列の積 (A, B) 7→ AB, 命
題の論理和 (P, Q) 7→ P ∨ Q, 集合の積 (A, B) 7→ A ∩ B などは二項演算である.
一項演算と二項演算が混ざっている表式では, 一項演算を優先する. たとえ
ば, A ∩ Bc では, まず一項演算 Bc を先に行い, そのあとで A と積をとるので,
ことさら A ∩ (Bc
) と書く必要はない. 一方, 積を先に行う場合は (A ∩ B)
c と
書く必要がある.
一般に, 集合 X にいくつかの演算が与えられたものを代数系という. 基本的
な代数系として, 半群, 群, 環, 体, 束などがある.</p>
</div>
<div class="paragraph data-line-62">
<p>JavaScriptを含むプログラミングでは拡大解釈
多くの<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Expressions_and_Operators">演算子</a>は関数です。</p>
</div>
<div class="sect2 data-line-65">
<h3 id="_単項演算子">7.1. 単項演算子</h3>
<div class="imageblock data-line-67">
<div class="content">
<img src="./img/2-7-2020-16-21-21-PM.png" alt="2 7 2020 16 21 21 PM">
</div>
</div>
<div class="paragraph data-line-69">
<p><code>f(5)</code> というのも単項演算だと言えます。</p>
</div>
<div class="imageblock data-line-71">
<div class="content">
<img src="./img/1-10-2020-09-24-26-AM.png" alt="1 10 2020 09 24 26 AM">
</div>
</div>
</div>
<div class="sect2 data-line-73">
<h3 id="_二項演算子">7.2. 二項演算子</h3>
<div class="paragraph data-line-75">
<p>二項演算子は2つインプットがあるのでカリー化すると高階関数です。</p>
</div>
<div class="imageblock data-line-79">
<div class="content">
<img src="./img/2-7-2020-15-41-27-PM.png" alt="2 7 2020 15 41 27 PM">
</div>
</div>
<div class="imageblock data-line-81">
<div class="content">
<img src="./img/0-7-2020-21-07-02-PM.png" alt="0 7 2020 21 07 02 PM">
</div>
</div>
<div class="imageblock data-line-83">
<div class="content">
<img src="./img/2-7-2020-15-48-34-PM.png" alt="2 7 2020 15 48 34 PM">
</div>
</div>
<div class="paragraph data-line-85">
<p><span class="image"><img src="./img/2-7-2020-15-47-45-PM.png" alt="2 7 2020 15 47 45 PM"></span></p>
</div>
<div class="paragraph data-line-90">
<p>plus = (a,b) &#8658; a+b;</p>
</div>
<div class="paragraph data-line-92">
<p>は二項演算</p>
</div>
<div class="paragraph data-line-99">
<p>二項演算子は　X　+ X のように中間に置かれるので、そのまま中置記法とよばれていて、</p>
</div>
<div class="sect3 data-line-101">
<h4 id="_中置演算子">7.2.1. 中置演算子</h4>
<div class="paragraph data-line-102">
<p>中置演算子も関数の表記のひとつです。</p>
</div>
<div class="imageblock data-line-104">
<div class="content">
<img src="./img/2-7-2020-16-22-33-PM.png" alt="2 7 2020 16 22 33 PM">
</div>
</div>
<div class="imageblock data-line-106">
<div class="content">
<img src="./img/2-7-2020-16-23-27-PM.png" alt="2 7 2020 16 23 27 PM">
</div>
</div>
<div class="paragraph data-line-109">
<p>JavaScriptには、以前から<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math/pow">Math.pow()</a>という累乗あるいは冪(べき)乗の関数が存在していましたが、<br>
<code>**</code> という冪乗の演算子がES2016新機能として登場しました。</p>
</div>
<div class="listingblock data-line-114">
<div class="title">2の3乗</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">    console.log(
      Math.pow(2, 3)
    ); <i class="conum" data-value="1"></i><b>(1)</b>

    console.log(
      2 ** 3
    ); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-124">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>8</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>8</td>
</tr>
</table>
</div>
<div class="paragraph data-line-126">
<p>二項演算子の中置記法を使うメリットは、
我々は義務教育の数学でさんざんトレーニングされていて直感的かつ正確に関数の挙動が把握できることです。</p>
</div>
<div class="paragraph data-line-129">
<p>f(x)表記は単項演算は簡潔で、実際便利に使いますが、
上記のように二項演算（カリー化すると高階関数）になると、中置記法にしたほうが直感的に正確なイメージがつかみやすくなります。</p>
</div>
<div class="paragraph data-line-132">
<p>また連鎖しやすくなります。</p>
</div>
</div>
<div class="sect3 data-line-134">
<h4 id="_オブジェクトのメソッド">7.2.2. オブジェクトのメソッド</h4>
<div class="paragraph data-line-136">
<p>1 + 2</p>
</div>
<div class="paragraph data-line-138">
<p>plus = (a,b) &#8658; a+b;</p>
</div>
<div class="paragraph data-line-140">
<p>は二項演算</p>
</div>
<div class="paragraph data-line-142">
<p>plus = a &#8658; b &#8658; a + b;</p>
</div>
<div class="paragraph data-line-144">
<p>カリー化して</p>
</div>
<div class="paragraph data-line-146">
<p>plus(1, 2)
plus(1)(2)</p>
</div>
<div class="paragraph data-line-149">
<p>単項演算</p>
</div>
<div class="paragraph data-line-151">
<p>オブジェクトのメソッドにする</p>
</div>
<div class="paragraph data-line-153">
<p>plus(this)(2)</p>
</div>
<div class="listingblock data-line-157">
<div class="title">2の3乗</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  Object.defineProperty(
    Number.prototype,
    'plus',
    {
      value: function (b) {
        return this + b;
      },
      enumerable: false,
      configurable: false,
      writable: false
    }
  );

  console.log(
    1 + 2
  );
    console.log(
    1 + 2 + 3
  );

  console.log(
    1['plus'](2)
  );
  console.log(
    1['plus'](2)['plus'](3)
  );

  console.log(
    1.plus(2)
  );
  console.log(
    1.plus(2).plus(3)
  );
  console.log(
    1.plus(2)
     .plus(3)
  )</code></pre>
</div>
</div>
<div class="paragraph data-line-197">
<p>オブジェクトのメソッドチェーンは、二項演算の連鎖</p>
</div>
<div class="paragraph data-line-199">
<p>裏を返すと、オブジェクトのメソッド定義をすることで、JavaScriptでも二項演算の中置演算子を自由に定義可能ということになります。</p>
</div>
<div class="paragraph data-line-201">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" class="bare">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p>
</div>
<div class="listingblock data-line-205">
<div class="title">2の3乗</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">  const customOperator = op =&gt; set =&gt; f =&gt;
    Object.defineProperty(set, op,
      {
        value: function (b) {
          return f(this)(b);
        },
        enumerable: false,
        configurable: false,
        writable: false
      });

  customOperator('+')
    (Number.prototype)
    (a =&gt; b =&gt; a + b);

  console.log(
    1['+'](2)
  );
  console.log(
    1['+'](2)['+'](3)
  );

  customOperator('-')
    (Number.prototype)
    (a =&gt; b =&gt; a - b);

  console.log(
    3['-'](2)
  );
  console.log(
    3['-'](2)['-'](1)
  );</code></pre>
</div>
</div>
<div class="paragraph data-line-240">
<p>Array.map(f)</p>
</div>
<div class="paragraph data-line-242">
<p>Arrayオブジェクトに最初から実装されている組み込み関数（オブジェクト指向の用語でいうとメソッド）
はArrayオブジェクトと関数の二項演算</p>
</div>
</div>
<div class="sect3 data-line-247">
<h4 id="_fx表記を避ける">7.2.3. f(x)表記を避ける</h4>
<div class="imageblock data-line-249">
<div class="content">
<img src="./img/2-7-2020-16-25-08-PM.png" alt="2 7 2020 16 25 08 PM">
</div>
</div>
<div class="paragraph data-line-251">
<p>全く同じ意味でも二項演算子では簡潔に書けるものが、f(x)記法では入れ子になってしまい煩雑になってしまいます。</p>
</div>
</div>
<div class="sect3 data-line-254">
<h4 id="_パイプライン演算子pipeline_operator_2">7.2.4. パイプライン演算子(Pipeline operator)</h4>
<div class="imageblock data-line-256">
<div class="content">
<img src="./img/2-7-2020-16-26-11-PM.png" alt="2 7 2020 16 26 11 PM">
</div>
</div>
<div class="paragraph data-line-258">
<p>パイプライン演算子は、インプットが関数である、高階関数であり、二項演算子。</p>
</div>
<div class="imageblock data-line-260">
<div class="content">
<img src="./img/2-7-2020-16-27-44-PM.png" alt="2 7 2020 16 27 44 PM">
</div>
</div>
<div class="paragraph data-line-262">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Pipeline_operator" class="bare">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Pipeline_operator</a></p>
</div>
<div class="paragraph data-line-264">
<p>関数呼び出しの連結</p>
</div>
<div class="paragraph data-line-266">
<p>パイプライン演算子は、複数の関数の連結を読みやすくすることができます。</p>
</div>
<div class="listingblock data-line-271">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="js" class="language-js hljs">const double = n =&gt; n * 2;
const increment = n =&gt; n + 1;

// パイプライン演算子なし
double(increment(double(double(5)))); // 42

// パイプライン演算子あり
5 |&gt; double |&gt; double |&gt; increment |&gt; double; // 42</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-284">
<h3 id="_三項演算子条件演算子">7.3. 三項演算子(条件演算子)</h3>
<div class="paragraph data-line-286">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" class="bare">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Conditional_Operator</a></p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1">
<h2 id="_functor">8. Functor</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="admonitionblock caution data-line-24">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph data-line-25">
<p>完成から程遠い　10％以下　のドキュメント</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock data-line-28">
<div class="content">
<img src="./img/5-7-2020-23-08-26-PM.png" alt="5 7 2020 23 08 26 PM">
</div>
</div>
<div class="paragraph data-line-130">
<p><span class="image"><img src="./img/5-8-2020-03-07-35-AM.png" alt="5 8 2020 03 07 35 AM"></span></p>
</div>
</div>
</div>
<div class="sect1 data-line-1">
<h2 id="_monadモナドfrp">9. Monad(モナド)　FRP</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="admonitionblock caution data-line-23">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph data-line-24">
<p>完成から程遠い　10％以下　のドキュメント</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-28">
<p>当面、</p>
</div>
<div class="paragraph data-line-30">
<p>30分でわかるJavaScriptプログラマのためのモナド入門
<a href="https://kentutorialbook.github.io/30minLearningJavaScriptMonad/" class="bare">https://kentutorialbook.github.io/30minLearningJavaScriptMonad/</a></p>
</div>
<div class="paragraph data-line-132">
<p>ブラッシュアップして本書に統合予定</p>
</div>
</div>
</div>
<div class="sect1 data-line-1">
<h2 id="_reactivemonad_io_next">10. ReactiveMonad io-next</h2>
<div class="sectionbody">
<style type="text/css">
th,td {
    border: solid 0px;
}
p>code {background-color: #aaaaaa};
td>code {background-color: #aaaaaa};
</style>
<div class="admonitionblock caution data-line-23">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph data-line-24">
<p>完成から程遠い　10％以下　のドキュメント</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-27">
<p><a href="https://github.com/stken2050/io-next" class="bare">https://github.com/stken2050/io-next</a></p>
</div>
</div>
</div>
<h1 id="_license" class="sect0 data-line-139">License</h1>

</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-12-22 14:59:34 +0900
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/tomorrow-night-eighties.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>