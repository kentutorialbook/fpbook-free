= ほぼすべてのプログラミング入門者が半ば強制的に辿る道＝命令型プログラミング
ifndef::stem[:stem: latexmath]
ifndef::imagesdir[:imagesdir: ../img/]
ifndef::source-highlighter[:source-highlighter: highlightjs]
ifndef::highlightjs-theme:[:highlightjs-theme: tomorrow-night]
ifndef::icons[:icons: font]

++++
<style type="text/css">
p >code {background-color: #aaaaaa};　
td >code {background-color: #aaaaaa};
</style>
++++

== Start from Scratch（ゼロからのスタート）

link:https://ja.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0[命令型プログラミング]（link:https://en.wikipedia.org/wiki/Imperative_programming[Imperative Programming]）は、コンピュータと呼ばれる物理的なハードウェアに順番に命令を送るという一連のシークエンスを並べる作業のことで、命令を送ればそのとおり動作するのだろう、という極めて自然で直感的にも理解しやすい原始的なやり方です。

2020年現在、ほぼすべてのプログラミング入門者は、まず命令型プログラミングの作法（link:https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0[プログラミングパラダイム] (link:https://en.wikipedia.org/wiki/Programming_paradigm[programming paradigm])）を徹底的に叩き込まれることになっています。


これは、古典的で素朴なプログラミングの作法を学ぶという意味では正しいかもしれません。そして将来的にこの状況が改革されるのかどうかも良くわかりません。

image::2-12-2020-14-26-30-PM.png[]

https://www.nhk.or.jp/school/programming/start/index.html

++++
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=kenec201702-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4865103929&linkId=a8910a2dbc778f885c734653a43b3f4f"></iframe>
++++

命令型プログラミングのコードとは以下のようなものです。

1から10までの数を足すコード

image::4-7-2020-05-45-46-AM.png[]

image::4-7-2020-05-48-23-AM.png[]

ここで、たとえば

`x = x + 1`

というコードがありますが、これは実際には3つの操作を表現しています。

1.`X` に割り当てられているメモリに格納された値を読み取る +
2.その値をひとつ増やす +
3.新しい値を `X` に割り当てられているメモリに書き込む

---

link:https://dl.acm.org/doi/10.1145/359576.359579[Can Programming Be Liberated from the von
Neumann Style? A Functional Style and Its
Algebra of Programs]

**プログラミングはフォン・ノイマン・スタイルから解放されうるか?関数型プログラミング・スタイルとそのプログラム代数**

という講演が、FORTRANの作者であるジョン・バッカスによってなされました。

どういうことでしょうか？


現代数学の基礎となる圏論を関数型プログラミングに紐づけて解説することで著名な数学者であるBartosz Milewski (@BartoszMilewski)氏は一連のYouTube動画の最初に以下のようにスピーチしています。

https://youtu.be/I8LbkfSSR58?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_

image::2-12-2020-15-19-38-PM.png[]
Ok、自分がプログラミングをはじめたとき、アセンブリ言語からはじめた。

image::2-12-2020-15-21-51-PM.png[]
考えうる限りもっとも低いレベルだね。何をすべきなのかを実際にコンピュータに正確に指示していく。

image::2-12-2020-15-22-58-PM.png[]
メモリからこれを掴み取って、それをレジスタに配置する、とか書いていく

image::2-12-2020-15-23-56-PM.png[]
それをアドレスとして利用して、そこにジャンプする、などなど、極めて正確にコンピュータに何をすべきか指示していく

image::2-12-2020-15-24-39-PM.png[]
これが、まさに我々が始めた命令型プログラミングのやり方というものだ。

image::2-12-2020-15-26-06-PM.png[]
そしてこれはどこかのポイントで、反学習する（忘れる）必要がある。

image::2-12-2020-15-26-57-PM.png[]
このプログラミングのアプローチは、コンピュータ・サイエンスでは、チューリングマシンと関連がある。

image::2-12-2020-15-27-43-PM.png[]
チューリングマシンは原始的なマシンで、紙テープがあってなんかスタンプしていくだけだ

image::2-12-2020-15-28-30-PM.png[]
ここにはハイレベルなプログラミンはない。それはちょうど

image::2-12-2020-15-29-42-PM.png[]
「番号を読み込め、テープにそれを書き戻せ、テープから何かを消せ」などなど、アセンブリ言語のようなものだ。

image::2-12-2020-15-30-38-PM.png[]
これは、ひとつのプログラミングへのアプローチではある。

image::2-12-2020-15-31-43-PM.png[]
ところで、こういうプログラミングへのアプローチは、コンピュータが存在する前から発明されていた。

image::2-12-2020-15-32-27-PM.png[]
それから、別のプログラミングへのアプローチがある。

image::2-12-2020-15-34-48-PM.png[]
これは数学からやってきたもので、アロンゾ・チャーチらによるラムダ計算だ。

image::2-12-2020-15-35-29-PM.png[]
これは「何が計算可能なのか」というようなものだ。

image::2-12-2020-15-36-42-PM.png[]

image::2-12-2020-15-37-32-PM.png[]
ものごとが実際にどのように実行できるのか、ある意味、ものごとを変換していく、という観点で数学的に考えていく。

---


link:https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97[ラムダ計算]は、関数型プログラミングの理論的基礎となっています。

理論的には、チューリングマシンに基礎を置く原始的な命令型プログラミングは、link:https://ja.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E5%8F%AF%E8%83%BD%E6%80%A7%E7%90%86%E8%AB%96[計算可能性]や、link:https://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A3%E3%83%BC%E3%83%81%EF%BC%9D%E3%83%81%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E3%83%86%E3%83%BC%E3%82%BC[チャーチ＝チューリングのテーゼ]という理論により、ラムダ計算に基礎を置く関数型プログラミングと同じ、計算可能な範囲も能力も一致する、ということが証明されています。


[NOTE]
.link:https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis[Church–Turing thesis]
====
1930年代に、計算可能性の概念を形式化するために、いくつかの独立した試みが行われました。

- 1933年、KurtGödelはJacques Herbrandとともに、一般的な再帰関数と呼ばれるクラスの正式な定義を作成しました。一般的な再帰関数のクラスは、すべての定数関数、射影、後継関数を含み、関数の合成、再帰、および最小化の下で閉じられる最小のクラスの関数（おそらく複数の引数を持つ）です。
- 1936年、アロンゾチャーチは、λ計算と呼ばれる関数を定義する方法を作成しました。ラムダ計算の中で、彼はチャーチ数と呼ばれる自然数の符号化を定義しました。自然数の関数は、チャーチ数の対応する関数がλ計算の項で表すことができる場合、**λ計算可能**と呼ばれます。
- また、1936年、教会の仕事を学ぶ前に、アランチューリングは、テープ上の記号を操作することによって入力から計算を実行できる、現在チューリングマシンと呼ばれるマシンの理論モデルを作成しました。自然数をシンボルのシーケンスとして適切にエンコードすると、チューリングマシンがエンコードされた自然数で対応する関数を計算する場合、自然数の関数は**チューリング計算可能**と呼ばれます。

**ChurchとTuringは、これら3つの正式に定義された計算可能関数のクラスが一致することを証明しました。**関数はTuring計算可能である場合に限り、また一般再帰的である場合にのみλ計算可能です。これにより、数学者とコンピューターサイエンティストは、計算可能性の概念がこれら3つの同等のプロセスによって正確に特徴付けられると信じるようになりました。計算可能性を特徴づける他の正式な試みは、その後、この信念を強化しました。
====

いきなり小難しいことが並んでいるように見えますが、ここで示されている超重要な事実とは、

**これまで原始的な手法として最初に習う、命令型プログラミングが扱える問題の範囲と処理能力は** +
↓ +
**これからやろうとする、関数型プログラミングが扱える問題の範囲と処理能力に等しい**

ことが、数学的に証明されている、ということで、命令型プログラミングで可能だったのならば、それはすべて漏れなく関数型プログラミング**だけ**で実現可能です。

この超重要な事実は、伊達や酔狂や希望的観測により主張されているのではなく、偉人らによって数学的に厳密に検証され担保されています。


これまで曲がりなりにも、命令型プログラミングでうまくいっていたのに、これから関数型プログラミングを積極的に導入していった場合、なにかが急に出来なくなってしまう！？？という**「関数型プログラミングによる理論的制限」などは存在しない**、安心して大丈夫だよ？ということです。


もういちど、スクラッチのコードを見ると、

image::4-7-2020-05-45-46-AM.png[]

10回繰り返す、など全体が「流れ」になっていることが確認できますが、これを３つの要素に還元したのが、

link:https://en.wikipedia.org/wiki/Structured_program_theorem[構造化定理(Structured program theorem)]です。


[NOTE]
.Structured program theorem
====
image::4-12-2020-15-12-46-PM.png[]
_NS図（青）とフローチャート（緑）を使用した、構造化プログラム定理の3つの基本パターン（順次、分岐１００、繰り返し）のグラフィック表現。_

構造化プログラムの定理、Böhm–Jacopini theoremとも呼ばれる。プログラム言語理論のひとつの帰結です。

link:https://en.wikipedia.org/wiki/Control-flow_graph[コントロールフローグラフ/ontrol-flow graph (CFG)]

image::4-12-2020-15-26-31-PM.png[]

これは、歴史的にこの文脈では、link:https://en.wikipedia.org/wiki/Flowchart[フローチャート(flowcharts)]と呼ばれているものだが、 +
**ただ３つの特定の方法(link:https://en.wikipedia.org/wiki/Control_flow[コントロールフロー])だけでサブプログラムを組み合わせると、 +
いかなる計算可能な関数(link:https://en.wikipedia.org/wiki/Computable_function[computable function])も計算できる**、 +
ということを述べています。それらは、

- **1つのサブプログラムを実行し、次に別のサブプログラムを実行する（順次）**
- **ブール式の値に従って2つのサブプログラムのいずれかを実行する（分岐）**
- **ブール式が真である限り、サブプログラムを繰り返し実行する（反復）**

この定理は、link:https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0[構造化プログラミング]の基礎を形成します。これは、gotoコマンドを避け、サブルーチン、順次、分岐、および反復を排他的に使用するプログラミングパラダイムです。
====

構造化定理では、**順次、分岐、反復の3要素だけで、いかなる計算可能な関数も計算できる、**と示しているのだから、これはすなわちlink:https://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E5%AE%8C%E5%85%A8[チューリング完全(Turing-complete)]あるいは、**万能チューリングマシン**である、と呼ばれているものと同じ意味です。

いったん、コンピュータのプログラミング言語がチューリング完全な能力に到達すると、それ以上、原理的に計算能力が広がる、上がるなんてことはありません。チューリング完全になってるか、なってないかの二択です。

そしてそれは、つまるところ、順次、分岐、反復の3要素がしっかり揃っているのか？ということだけで比較的容易に判別できてしまうわけです。

== まとめ

**1.チューリングマシンに基礎を置く原始的な命令型プログラミングは、構造化プログラミングでいうと、順次、分岐、反復の3要素でフローをコントロールすると、チューリング完全となり、計算可能な範囲でなんでもできるようになる。**

**２．チューリングマシンに基礎を置く原始的な命令型プログラミングは、ラムダ計算に基礎を置く関数型プログラミングに完全に置き換えることが可能。**


従って、１と２によると、

**命令型あるいは少し洗練された構造型プログラミングを脱却して、** +
**関数型プログラミングを実践することは原理的に、** +
**順次、分岐、反復の3要素を**すべて +
**ラムダ計算に置き換える**

ということになります。




