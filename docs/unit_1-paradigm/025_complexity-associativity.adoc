= 複雑さとの闘いのための最終兵器＝結合性
ifndef::stem[:stem: latexmath]
ifndef::imagesdir[:imagesdir: ../img/]
ifndef::source-highlighter[:source-highlighter: highlightjs]
ifndef::highlightjs-theme:[:highlightjs-theme: tomorrow-night]
ifndef::icons[:icons: font]

++++
<style type="text/css">
p >code {background-color: #aaaaaa};　
td >code {background-color: #aaaaaa};
</style>
++++

== コーディングは複雑さとの闘い
　
コーディングは複雑さとの闘いです。

その最終兵器となるものが、結合性である、というもっとも重要な話をします。

image::4-12-2020-17-32-03-PM.png[]

こうなると説明しました。

素晴らしいことのように思えます。

image::4-12-2020-17-34-42-PM.png[]

ではこれは同じでしょうか？

いい加減まどろっこしくなってきたので、数式に戻しましょう。

stem:[(1 + 2) + 3 = 1 + 2 + 3]

です。では、

stem:[1 + 2 + 3 = 1 + (2 + 3)]

なのか？

この場合、もちろんそうで、

stem:[(1 + 2) + 3 = 1 + 2 + 3 = 1 + (2 + 3)]

が成り立っています。

image:1-7-2020-09-05-29-AM.png[]

これは()で決まる、計算の順序によって値は異る！？というようなことはない、同じになる、ということで、 +
**結合性(associativity)がある、あるいは、結合法則(associative law)が成り立っている**、などと言い表します。

[NOTE]
.link:https://ja.wikipedia.org/wiki/%E7%B5%90%E5%90%88%E6%B3%95%E5%89%87[結合法則(associative law)]
====
二項演算が結合的ならば、その演算が反復して適用されるとき、その式においてきちんと（開きと閉じが）対になる括弧がどのように挿入されるかを気にすることなく、その演算結果が同じであることがわかる。そのことを一般化された結合法則 (generalized associative law) と言う。実例として、四つの元の積を、それらの因子の順番を変えることなく書き下せば、五種類の異なる計算順序が考えられる:

stem:[((ab)c)d]

stem:[(ab)(cd)]

stem:[(a(bc))d]

stem:[a((bc)d)]

stem:[a(b(cd))]

が、これらの積を得る演算が結合的ならば、一般化された結合法則の述べるに従い、これらすべてが同じ値の積であることが結論される。となれば（これらの式から括弧をすべて取り払った式に既に別の意味が施されているのでない限り）この積において括弧は「不要」のものと考えることができて、この積を紛れの虞なく

stem:[abcd]

と書くことができる。

**このような繰り返しの積において、因子となる元の数が増えるにしたがって、釣り合いのとれた括弧の挿入の仕方の総数は急速に増加するけれども、演算が結合的ならばそれらの区別もやはり必要がなくなる。**
====

重要なのは、最後の文章で、「もしも結合法則が成り立ってなかったら」カッコの挿入の仕方の総数が急速に増加する、という点です。

つまり、非常に初歩的な二項演算のレベルにおいて、すでに、

link:https://ja.wikipedia.org/wiki/%E7%B5%84%E5%90%88%E3%81%9B%E7%88%86%E7%99%BA[組み合わせ爆発]

というようなものが巻き起こってしまう、ということです。

掛け算には結合性があって、カッコのありなしによって決まる計算順序は気にする必要はなく、stem:[abcd]とだけ書けば良い、組み合わせ爆発は起こらないだろう、ということです。


== Monoid(モノイド)

image::0-12-2020-20-35-19-PM.png[]

こういう二項演算で結合性がある、つまり、

image::1-12-2020-10-59-33-AM.png[]

このように連鎖させたとき、（）がどこかについて計算順序がどんなふうに変えられたとしても、結果は同じになる、組み合わせ爆発など起こらない、複雑さの懸念がない、二項演算のことを、モノイドと呼びます。

厳密には

link:https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8E%E3%82%A4%E3%83%89[モノイド]
　
image:0-12-2020-20-43-23-PM.png[]

とかいろいろあるのですが、それは再度繰り返しとなりますが、_厳密な数学の説明は、土台から積み上げるとここまで到達するまでに分量が多いので、🟧 **UNIT 3 : 数学 Mathematics** へ切り分けています。_

ここでは、もっとも重要なのはあくまで**結合性**であり、代数構造のなかで特別視される重要な構造です。さらにいうと、単位元は、結合性さえあれば、後から絶対に、というか簡単に追加できるので、単位元のあるなしはろくに区別されていないということもあります。（この説明も後回しですっとばします）

== レゴブロックは Monoid(モノイド)

数式ではなくもっと身近な事例を考えることもできます。

たとえば、レゴブロックを考えてみましょう。

image::4-12-2020-18-02-16-PM.png[]

レゴブロックには結合性があります。結合法則を満たしている。


stem:[(レゴブロックA + レゴブロックB) + レゴブロックC]

stem:[レゴブロックA + (レゴブロックB + レゴブロックC)]

stem:[レゴブロックA + レゴブロックB + レゴブロックC]

上の接続パターンは結果同じになる、ということです。結合性がある。

同じ構成でさえあれば、それがどういう順番で組み立てられようが結果は同じになります。

これがもし、こっちのパーツを先に組み立ててからでないと、別のパーツと組み立てるタイミングが異なれば、別のものになってしまう。。。とかだったら、もう面倒臭すぎるでしょう。

== USB機器はMonoid(モノイド)

同じことはUSB機器にも言えます。

image::4-12-2020-18-06-58-PM.png[]

++++
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=kenec201702-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B07ST84PF5&linkId=d0b732b63dcc2116b7354a17d0ea7169"></iframe>
++++

USB機器には結合性があります。結合法則を満たしている。

USB機器を接続するときは、レゴと一緒で、どういう順番につながないと、目的の構成にならない！という面倒なことはありません。

たとえば、

USBハブをPCに接続してから、USBハブになにかUSB機器を接続する +
USBハブにUSB機器を接続してから、USBハブをPCに接続する

これは同じ構成になる、ということは皆知っているでしょう。

結合性があるって素晴らしいですね。 +
逆に結合性がない規格は非常に取り扱いの面倒なものになります。組み合わせ爆発が起こるわけで、まず使い物にはならないでしょう。

stem:[(PCのUSB端子 + USBハブ) + USB機器]

stem:[PCのUSB端子 + (USBハブ + USB機器)]

stem:[PCのUSB端子 + USBハブ + USB機器]

規格で一般化した表現にすると、


stem:[(USB機器 + USB機器) + USB機器]

stem:[USB機器 + (USB機器 + USB機器)]

stem:[USB機器 + USB機器 + USB機器]

上の接続パターンは結果同じ機器になる、ということです。結合性がある。

== 文字列はMonoid(モノイド)


同じように、文章、文字列、というのも結合性があります。

stem:[("結合性" + "が") + "ある"]

stem:["結合性" + ("が" + "ある")]

stem:["結合性" + "が" + "ある"]

つまり、

stem:[(文字列 + 文字列) + 文字列]

stem:[文字列 + (文字列 + 文字列)]

stem:[文字列 + 文字列 + 文字列]

文字列に結合性があって良かったです。もし文字列に結合性がなければ、コピペ、カットペーストの順番によって別の文章が出来上がるわけで、引用すらおちおちできず、組み合わせ爆発がおこり、我々の現代文明に致命的な悪影響を及ぼしていたことでしょう。

このように非常に低レベルな二項演算だけでも、恐ろしい複雑性と戦うためには、扱う対象に結合性をもたせておく、というのは死活問題です。

関数型プログラミングを実践するにあたり、結合性は最重要視され、最優先事項となります。

つまり、関数型プログラミングの式は、二項演算が中心となりますが、その値と二項演算子のペアは結合性を満たすものを特別待遇し、合理的理由がないかぎり、結合性のないものは可能な限り排除します。理由もないのに結合性を満たさない式を構築すると、組み合わせ爆発が起こってしまい、コントロール不能になってしまうからです。



