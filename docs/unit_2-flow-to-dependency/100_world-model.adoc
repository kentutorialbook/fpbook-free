= 世界モデル
ifndef::stem[:stem: latexmath]
ifndef::imagesdir[:imagesdir: ../img/]
ifndef::source-highlighter[:source-highlighter: highlightjs]
ifndef::highlightjs-theme:[:highlightjs-theme: tomorrow-night]
ifndef::icons[:icons: font]

++++
<style type="text/css">
p >code {background-color: #aaaaaa};　
td >code {background-color: #aaaaaa};
</style>
++++


== 関数型プログラミングの実用化に立ち塞がる最大のメンタルブロック

実際この問題は、関数型プログラミング、そしてプログラミング全般において、かなり重要でありながらも、根本的な要点では、きちんと語られないトピックであり、自分がことあるごとに語ろうとしているトピックでもあります。

そもそも、値の書き換えってなんでしょうか？

純粋関数型プログラミングは、純粋に数学的なプログラミングです。

値A = 1

というのがあるとします。

この値を書き換える、っていうのは、

値A= 2

とかにするということですよね？

これ、数学的には破綻しています。義務教育を受けていれば誰でもすぐにわかることです。

もしくは、「いやこれはプログラミング特有の代入なんで、数学的には破綻していない！」というのであれば、「数学とは違うプログラミング特有のまた別のなにかの概念」を暗黙に導入しながら数学的ではない方法を採用している、ということなので、いずれにせよ純粋に数学的なプログラミングはやってない、ということになります。

純粋関数型プログラミングあるいは単に関数型プログラミングではない、（原始的な）命令型プログラミング のパラダイムでは、このような数学的に破綻した作法が当然のようにまかりとおっています。

しかし数学的に破綻しているのは、数学的な作業であるプログラミングではかなりマズいわけなので、こういう値を書き換える真似は避けよう、とすれば「値の不変性」、英語で言えばイミュータブル(immutable)という関数型プログラミング御用達の概念となります。

さて、ここで重大な問題が発生してしまいます。「現実世界」ってのはmutableです。現実世界というのは刻一刻と変化していきます。数学的整合性のあるimmutableで一貫したプログラミングなんぞは机上の空論で、だから関数型プログラミングなんて理想論は現実的なアプリケーションを開発するのには使いものにはならない、と思われがちというか、実際にそう思われていた時期も長かったように思います。

== 世界モデル　数学と物理学と時間

整理すると、

現実世界 mutable +
数学世界 immutable +
こういうマインドセットがまずあるわけです。

両者は一致しません、じゃあどうしよう？

原始的な命令型パラダイム、あるいはオブジェクト指向の大半の作法では、我々の素朴な直感に忠実に従って、数学世界のほうを捻じ曲げて、

現実世界 mutable
似非数学世界 mutable
とします。これで現実世界と似非数学世界の一致となりました。

似非数学世界、っていうのは

値A = 1

値A= 2

みたいな並びを普通に許容する、コードの並び方に完全に依存して論理が決まっていく世界です。数学っていうよりもコードの並び方のほうが重要なんです。

この、似非数学世界での各種操作が旧来の意味での原始的なプログラミングの作法である、と言えるでしょう。数学的不整合についてはその都度ごまかしごまかしやっていくわけです。

根本的に何かが間違っている。何か見落としている。それは「時間」の概念です。

とても不思議な現象として、世のほとんどすべてのプログラマは「時間」についてはまるで語りたがりません。まるで、そんなことはプログラミングの範疇外であるかのようにガン無視しています。とても大事なことなんですけどね。

だって、きちんと時間の概念を導入してやれば、

時間t1,t2で

値A(t1) = 1

値A(t2)= 2

とできて、数学的に破綻しなくなるじゃないですか？それだけのことです。

これだとコードの並びに依存しません、入れ替わったって別に大丈夫です。純粋に数学的だと言えます。

でもそういう風にここで、あるいは別のところでも、プログラミングのトピックで自分がこぞって「時間」について語ろうとすると、「なんかまた独自思想でポエムを語ってるやつがいる」というのが予想されうるプログラミング界隈の通常の反応でしょう。なぜか話が通じません。これまでこの手の話を書いたら何度も炎上させられました（笑　非常に愚かなことですがそれが現実です。

そこで、今から「権威」を引用します。知的な活動としては本来は推奨されない権威主義ですが、少なくとも権威の下では連中は無駄な文句は言わず黙ってくれるのでとても助かります。

関数型プログラミングの界隈でバイブル化されている計算機プログラムの構造と解釈(SICP)を引用しましょう。

image::2-12-2020-17-02-00-PM.png[]


SICPが優れている理由のひとつには、このテクストにはちゃんと物理学の視点があることです。つまり「この現実世界のこと」をちゃんと論じてくれています。この要素に触れているプログラミング書籍は非常に稀です。

関数型プログラミングと時間の関係について秀逸な視点が強調されているのですが、この本はやたらバイブル化されてるわりに、そこで論じられている時間の視点について、きちんと評価して論評されているのはほとんど見たことがありません。それだけ世のプログラマというのはプログラムと時間の概念を結びつけて語るのが苦手、というか嫌いなのでしょう。

以下、長いですが、随時太字にしながら読む価値が大きいところを引用します。訳にはずいぶんと不満がありますが、今回は許容することにします。ただ要所でこれはさすがにまずいと感じる文は適時翻訳しなおしています。

引用文中に頻出する「代入」というのは、ここで問題となっている値の書き換えのこと＝命令型プログラミングのいわゆるmutableな「破壊的代入」のことです。


http://vocrf.net/docs_ja/jsicp.pdf


[quote]

----
3.5 ストリーム

ここまでで、モデル化の道具としての代入について十分理解し、また代入が引き起こす複雑な問題も認識できました。このあたりで、私たちがもし別の取り組み方をしていたら、これらの問題のいくつかは避けられたのではないかということを考えてみてもいいころです。この節では、状態をモデル化する別のアプローチについて検討します。このアプローチは、ストリーム (stream) と呼ばれるデータ構造に基づくものです。ここから先で見ていくように、状態をモデル化する際に生じる複雑性の一部をストリームによって軽減できます。

一歩下がって、この複雑性というものがどこから来ているのか再検討してみましょう。現実世界の現象をモデル化しようとする中で、見たところもっともな決定をいくつかしてきました。局所状態を持つ現実世界のオブジェクトを局所変数を持つ計算オブジェクトによってモデル化し、現実世界の時間の変化をコンピュータ上の時間変化と同一視し、コンピュータ上のモデルオブジェクトの状態の経時変化はモデルオブジェクトの局所変数に対する代入として実装しました。

ほかのアプローチはないのでしょうか。モデル対象の世界での時間とコンピュータ上の時間を同一視することは避けられないのでしょうか。変化する世界での現象をモデル化するには、時間とともにモデルを変化させるしかないのでしょうか。この問題について、数学関数を使って考えてみましょう。量 x の時間によって変化するふるまいは、時間の関数 x(t) として記述できます。もし時刻ごとの x に注目するなら、それを変化する量として捉えることになります。しかし、全時間を通しての値の履歴に注目するなら、変化については重要視しないことになります。関数そのものは変化しないことになるからです。（物理学では、運動について考える手段として粒子の “世界線” を導入することによって、この見方を採用することがあります。）

もし時間を離散ステップで測るのであれば、時間関数は (無限かもしれない) 列としてモデル化できます。この節では、モデル化対象システムの時間履歴を表現する列によって変化をモデル化する手法について見ていきます。これを達成するために、ストリーム (stream) と呼ばれる新しいデータ構造を導入します。抽象的な視点から見ると、ストリームはただの列です。しかし、ストリームを (2.2.1 節のように) 素直にリストとして実装したものでは、ストリーム処理の本来の力が見えてきません。その代わりに、ここでは遅延評価 (delayed evaluation) というテクニックを導入します。遅延評価を使うことによって、非常に大きな (無限でもありうる) 列をストリームして表現することが可能になります。

ストリーム処理によって、状態のあるシステムを代入や可変データを使わずにモデル化できるようになります。このことは、論理的にも実用的にも大きな意味があります。代入の導入につきもののマイナス点を避けてモデルを構築できるからです。

時間の関数型プログラミング的視点

ここで、この章の初めで提起したオブジェクトと状態の問題に戻って、これらの問題を新しい観点から検討してみましょう。この章の初めでは代入と可変オブジェクトを導入し、状態を持つシステムをモデル化するプログラムをモジュール式に構築するメカニズムを提供しました。また、局所変数を持つ計算オブジェクトを構築し、これらの変数を代入によって変更しました。そして、この世界に存在するオブジェクトの経時的なふるまいを、対応する計算オブジェクトの経時的なふるまいによってモデル化しました。

その後、ストリームを使うことによっても、局所状態を持つオブジェクトをモデル化できるということを見てきました。オブジェクトの局所状態のような変化していく量は、逐次的な状態の時間履歴を表現するストリームによってモデル化できます。本質的に、ストリームによって時間を明示的に表現することによって、シミュレートされた世界の中での時間と、評価の間に起こるイベントの順番とを切り離すということをしていることになります。実際に、delayというものが存在するので、モデル中のシミュレートされた時間と、評価の間に起こるイベントの順番との間に、ほとんど関係がないということもありえます。

（引用中略）

stream-withdraw は、出力が入力によって完全に決定される、明確に定義された数学関数を実装しています。しかし、ここで入力 amount-stream がユーザーのタイプする一連の値のストリームで、結果の残高ストリームは画面に表示されていると考えてみてください。そうすると、値をタイプし結果を見ているユーザーの視点からは、このストリーム処理は make-simplified-withdraw によって作られたオブジェクトと同じふるまいを持っていることになります。しかしストリーム版では、代入も局所状態もなく、このため3.1.3 節で直面したような理論的な困難もありません。それなのに、システムには状態があるのです！

これはかなりすごいことです。stream-withdraw は、ふるまいが変わったりしない明確に定義された数学関数を実装しているにもかかわらず、ここでのユーザーの知覚は、変化する状態を持つシステムと対話しているときと同じなのです。このパラドックスを解くひとつの見方は、ユーザの時限的な存在性こそが、システムには状態がある、ということを強制している、ということです。もしユーザーがシステムとの対話から一歩下がって、個々の取引ベースで考えるのをやめて残高のストリームという考え方をするなら、システムは状態を持たないように見えるでしょう。

複雑な処理のある一部から見ると、ほかの部分は時間とともに変化するように見えます。それらは時間によって変わる局所状態を持っています。私たちの世界に存在するこの種の自然な分解方法 (これは、私たちが世界の一部としての視点から世界を見るやり方と同じです) をモデル化したプログラムをコンピュータ中の構造を使って書こうと思うと、関数的でない計算オブジェクトを作ることになります。オブジェクトは変化しなければならないからです。状態は局所状態変数によってモデル化し、状態の変更はこれらの変数に対する代入によってモデル化します。こうすることによって、計算実行の時間が私たちのいるこの世界の時間をモデル化するようにします。その結果、コンピュータの中に “オブジェクト” ができることになります。

オブジェクトを使ったモデル化は強力で直感的です。その大きな理由となっているのは、このやり方が私たちがこの世界と関わる際の認知にマッチしているということです。しかし、この章を通して何度も見てきたように、これらのモデルは、イベント順の制約や、複数プロセスの同期といった、厄介な問題を引き起こします。

関数型プログラミング言語 (functional programming language) の発展は、これらの問題を避けられるという見込みによって促進されてきました。関数型プログラミング言語は代入や変更可能なデータを提供しません。このような言語では、すべての手続きは引数に対する明確な数学関数を実装することになり、挙動は変化しません。並列システムを扱うには、関数型のアプローチは非常に魅力的です。

（物理でも同じように、動く粒子を観測しているとき、粒子の位置 (状態) は変化していると言われるでょう。しかし、時空の中での粒子の世界線という視点からは、変化というものは存在しません。）
----

ここで、

「オブジェクトを使ったモデル化」というのは、もちろん（原始的）命令型プログラミング、あるいは普通に宣言型パラダイムでもなんでもないタイプのオブジェクト指向のことで、直感的、私たちがこの世界と関わる際の認知にマッチしている、コンピュータ上のモデルオブジェクトの状態の経時変化はモデルオブジェクトの局所変数に対する代入として実装、代入が引き起こす複雑な問題がある

現実世界 mutable +
似非数学世界 mutable +
他方で、

「ストリーム処理によって、状態のあるシステムを代入や可変データを使わずにモデル化」とは関数型リアクティブプログラミング（Functional reactive programming/FRP）のことです。

時間の関数型プログラミング的視点

関数型プログラミング言語 (functional programming language) の発展は、これらの問題を避けられるという見込みによって促進されてきました。関数型プログラミング言語は代入や変更可能なデータを提供しません。←数学世界 immutable

量 x の時間によって変化するふるまいは、時間の関数 x(t) として記述

（物理でも同じように、動く粒子を観測しているとき、粒子の位置 (状態) は変化していると言われるでょう。しかし、時空の中での粒子の世界線という視点からは、変化というものは存在しません。）

つまり、

現実世界 immutable +
数学世界 immutable +
と、現実世界も数学・物理学的な俯瞰では、なんのことはないimmutableである、と統合してしまいます。

これは、理論物理学の素養があれば、ごく普通の世界観でしょう。

image::2-12-2020-17-06-53-PM.png[]

link:https://www.amazon.co.jp/Stubbornly-Persistent-Illusion-Essential-Scientific/dp/076243564X[A Stubbornly Persistent Illusion: The Essential Scientific Works of Albert Einstein | スティーブン・ホーキング]

 The distinction between the past, present and future is only a stubbornly persistent illusion.
 過去、現在、未来の区別というのは、頑固につきまとう幻想に過ぎない
 - アルバート・アインシュタイン
